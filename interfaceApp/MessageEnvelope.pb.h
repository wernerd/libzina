// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageEnvelope.proto

#ifndef PROTOBUF_INCLUDED_MessageEnvelope_2eproto
#define PROTOBUF_INCLUDED_MessageEnvelope_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_MessageEnvelope_2eproto 

namespace protobuf_MessageEnvelope_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_MessageEnvelope_2eproto
namespace zina {
class MessageEnvelope;
class MessageEnvelopeDefaultTypeInternal;
extern MessageEnvelopeDefaultTypeInternal _MessageEnvelope_default_instance_;
class RatchetData;
class RatchetDataDefaultTypeInternal;
extern RatchetDataDefaultTypeInternal _RatchetData_default_instance_;
}  // namespace zina
namespace google {
namespace protobuf {
template<> ::zina::MessageEnvelope* Arena::CreateMaybeMessage<::zina::MessageEnvelope>(Arena*);
template<> ::zina::RatchetData* Arena::CreateMaybeMessage<::zina::RatchetData>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zina {

// ===================================================================

class MessageEnvelope : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.MessageEnvelope) */ {
 public:
  MessageEnvelope();
  virtual ~MessageEnvelope();

  MessageEnvelope(const MessageEnvelope& from);

  inline MessageEnvelope& operator=(const MessageEnvelope& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageEnvelope(MessageEnvelope&& from) noexcept
    : MessageEnvelope() {
    *this = ::std::move(from);
  }

  inline MessageEnvelope& operator=(MessageEnvelope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MessageEnvelope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageEnvelope* internal_default_instance() {
    return reinterpret_cast<const MessageEnvelope*>(
               &_MessageEnvelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MessageEnvelope* other);
  friend void swap(MessageEnvelope& a, MessageEnvelope& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageEnvelope* New() const final {
    return CreateMaybeMessage<MessageEnvelope>(NULL);
  }

  MessageEnvelope* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageEnvelope>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MessageEnvelope& from);
  void MergeFrom(const MessageEnvelope& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MessageEnvelope* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string scClientDevId = 2;
  bool has_scclientdevid() const;
  void clear_scclientdevid();
  static const int kScClientDevIdFieldNumber = 2;
  const ::std::string& scclientdevid() const;
  void set_scclientdevid(const ::std::string& value);
  #if LANG_CXX11
  void set_scclientdevid(::std::string&& value);
  #endif
  void set_scclientdevid(const char* value);
  void set_scclientdevid(const char* value, size_t size);
  ::std::string* mutable_scclientdevid();
  ::std::string* release_scclientdevid();
  void set_allocated_scclientdevid(::std::string* scclientdevid);

  // optional bytes supplement = 4;
  bool has_supplement() const;
  void clear_supplement();
  static const int kSupplementFieldNumber = 4;
  const ::std::string& supplement() const;
  void set_supplement(const ::std::string& value);
  #if LANG_CXX11
  void set_supplement(::std::string&& value);
  #endif
  void set_supplement(const char* value);
  void set_supplement(const void* value, size_t size);
  ::std::string* mutable_supplement();
  ::std::string* release_supplement();
  void set_allocated_supplement(::std::string* supplement);

  // optional bytes message = 5;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string msgId = 6;
  bool has_msgid() const;
  void clear_msgid();
  static const int kMsgIdFieldNumber = 6;
  const ::std::string& msgid() const;
  void set_msgid(const ::std::string& value);
  #if LANG_CXX11
  void set_msgid(::std::string&& value);
  #endif
  void set_msgid(const char* value);
  void set_msgid(const char* value, size_t size);
  ::std::string* mutable_msgid();
  ::std::string* release_msgid();
  void set_allocated_msgid(::std::string* msgid);

  // optional bytes recvIdHash = 7;
  bool has_recvidhash() const;
  void clear_recvidhash();
  static const int kRecvIdHashFieldNumber = 7;
  const ::std::string& recvidhash() const;
  void set_recvidhash(const ::std::string& value);
  #if LANG_CXX11
  void set_recvidhash(::std::string&& value);
  #endif
  void set_recvidhash(const char* value);
  void set_recvidhash(const void* value, size_t size);
  ::std::string* mutable_recvidhash();
  ::std::string* release_recvidhash();
  void set_allocated_recvidhash(::std::string* recvidhash);

  // optional bytes senderIdHash = 8;
  bool has_senderidhash() const;
  void clear_senderidhash();
  static const int kSenderIdHashFieldNumber = 8;
  const ::std::string& senderidhash() const;
  void set_senderidhash(const ::std::string& value);
  #if LANG_CXX11
  void set_senderidhash(::std::string&& value);
  #endif
  void set_senderidhash(const char* value);
  void set_senderidhash(const void* value, size_t size);
  ::std::string* mutable_senderidhash();
  ::std::string* release_senderidhash();
  void set_allocated_senderidhash(::std::string* senderidhash);

  // optional bytes recvDevIdBin = 10;
  bool has_recvdevidbin() const;
  void clear_recvdevidbin();
  static const int kRecvDevIdBinFieldNumber = 10;
  const ::std::string& recvdevidbin() const;
  void set_recvdevidbin(const ::std::string& value);
  #if LANG_CXX11
  void set_recvdevidbin(::std::string&& value);
  #endif
  void set_recvdevidbin(const char* value);
  void set_recvdevidbin(const void* value, size_t size);
  ::std::string* mutable_recvdevidbin();
  ::std::string* release_recvdevidbin();
  void set_allocated_recvdevidbin(::std::string* recvdevidbin);

  // optional .zina.RatchetData ratchet = 12;
  bool has_ratchet() const;
  void clear_ratchet();
  static const int kRatchetFieldNumber = 12;
  private:
  const ::zina::RatchetData& _internal_ratchet() const;
  public:
  const ::zina::RatchetData& ratchet() const;
  ::zina::RatchetData* release_ratchet();
  ::zina::RatchetData* mutable_ratchet();
  void set_allocated_ratchet(::zina::RatchetData* ratchet);

  // optional uint32 msgType = 3;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 3;
  ::google::protobuf::uint32 msgtype() const;
  void set_msgtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zina.MessageEnvelope)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_scclientdevid();
  void clear_has_scclientdevid();
  void set_has_msgtype();
  void clear_has_msgtype();
  void set_has_supplement();
  void clear_has_supplement();
  void set_has_message();
  void clear_has_message();
  void set_has_msgid();
  void clear_has_msgid();
  void set_has_recvidhash();
  void clear_has_recvidhash();
  void set_has_senderidhash();
  void clear_has_senderidhash();
  void set_has_recvdevidbin();
  void clear_has_recvdevidbin();
  void set_has_ratchet();
  void clear_has_ratchet();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr scclientdevid_;
  ::google::protobuf::internal::ArenaStringPtr supplement_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr msgid_;
  ::google::protobuf::internal::ArenaStringPtr recvidhash_;
  ::google::protobuf::internal::ArenaStringPtr senderidhash_;
  ::google::protobuf::internal::ArenaStringPtr recvdevidbin_;
  ::zina::RatchetData* ratchet_;
  ::google::protobuf::uint32 msgtype_;
  friend struct ::protobuf_MessageEnvelope_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RatchetData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.RatchetData) */ {
 public:
  RatchetData();
  virtual ~RatchetData();

  RatchetData(const RatchetData& from);

  inline RatchetData& operator=(const RatchetData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RatchetData(RatchetData&& from) noexcept
    : RatchetData() {
    *this = ::std::move(from);
  }

  inline RatchetData& operator=(RatchetData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RatchetData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RatchetData* internal_default_instance() {
    return reinterpret_cast<const RatchetData*>(
               &_RatchetData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RatchetData* other);
  friend void swap(RatchetData& a, RatchetData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RatchetData* New() const final {
    return CreateMaybeMessage<RatchetData>(NULL);
  }

  RatchetData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RatchetData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const RatchetData& from);
  void MergeFrom(const RatchetData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RatchetData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ratchet = 9;
  bool has_ratchet() const;
  void clear_ratchet();
  static const int kRatchetFieldNumber = 9;
  const ::std::string& ratchet() const;
  void set_ratchet(const ::std::string& value);
  #if LANG_CXX11
  void set_ratchet(::std::string&& value);
  #endif
  void set_ratchet(const char* value);
  void set_ratchet(const void* value, size_t size);
  ::std::string* mutable_ratchet();
  ::std::string* release_ratchet();
  void set_allocated_ratchet(::std::string* ratchet);

  // optional bytes mac = 10;
  bool has_mac() const;
  void clear_mac();
  static const int kMacFieldNumber = 10;
  const ::std::string& mac() const;
  void set_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_mac(::std::string&& value);
  #endif
  void set_mac(const char* value);
  void set_mac(const void* value, size_t size);
  ::std::string* mutable_mac();
  ::std::string* release_mac();
  void set_allocated_mac(::std::string* mac);

  // optional bytes remotePreKey = 12;
  bool has_remoteprekey() const;
  void clear_remoteprekey();
  static const int kRemotePreKeyFieldNumber = 12;
  const ::std::string& remoteprekey() const;
  void set_remoteprekey(const ::std::string& value);
  #if LANG_CXX11
  void set_remoteprekey(::std::string&& value);
  #endif
  void set_remoteprekey(const char* value);
  void set_remoteprekey(const void* value, size_t size);
  ::std::string* mutable_remoteprekey();
  ::std::string* release_remoteprekey();
  void set_allocated_remoteprekey(::std::string* remoteprekey);

  // optional bytes remoteIdKey = 13;
  bool has_remoteidkey() const;
  void clear_remoteidkey();
  static const int kRemoteIdKeyFieldNumber = 13;
  const ::std::string& remoteidkey() const;
  void set_remoteidkey(const ::std::string& value);
  #if LANG_CXX11
  void set_remoteidkey(::std::string&& value);
  #endif
  void set_remoteidkey(const char* value);
  void set_remoteidkey(const void* value, size_t size);
  ::std::string* mutable_remoteidkey();
  ::std::string* release_remoteidkey();
  void set_allocated_remoteidkey(::std::string* remoteidkey);

  // optional bytes preKeyHash = 14;
  bool has_prekeyhash() const;
  void clear_prekeyhash();
  static const int kPreKeyHashFieldNumber = 14;
  const ::std::string& prekeyhash() const;
  void set_prekeyhash(const ::std::string& value);
  #if LANG_CXX11
  void set_prekeyhash(::std::string&& value);
  #endif
  void set_prekeyhash(const char* value);
  void set_prekeyhash(const void* value, size_t size);
  ::std::string* mutable_prekeyhash();
  ::std::string* release_prekeyhash();
  void set_allocated_prekeyhash(::std::string* prekeyhash);

  // optional int32 useVersion = 1;
  bool has_useversion() const;
  void clear_useversion();
  static const int kUseVersionFieldNumber = 1;
  ::google::protobuf::int32 useversion() const;
  void set_useversion(::google::protobuf::int32 value);

  // optional int32 maxVersion = 2;
  bool has_maxversion() const;
  void clear_maxversion();
  static const int kMaxVersionFieldNumber = 2;
  ::google::protobuf::int32 maxversion() const;
  void set_maxversion(::google::protobuf::int32 value);

  // optional uint32 contextId = 3;
  bool has_contextid() const;
  void clear_contextid();
  static const int kContextIdFieldNumber = 3;
  ::google::protobuf::uint32 contextid() const;
  void set_contextid(::google::protobuf::uint32 value);

  // optional int32 curveType = 4;
  bool has_curvetype() const;
  void clear_curvetype();
  static const int kCurveTypeFieldNumber = 4;
  ::google::protobuf::int32 curvetype() const;
  void set_curvetype(::google::protobuf::int32 value);

  // optional uint32 flags = 5;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 5;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional int32 ratchetMsgType = 6;
  bool has_ratchetmsgtype() const;
  void clear_ratchetmsgtype();
  static const int kRatchetMsgTypeFieldNumber = 6;
  ::google::protobuf::int32 ratchetmsgtype() const;
  void set_ratchetmsgtype(::google::protobuf::int32 value);

  // optional int32 Np = 7;
  bool has_np() const;
  void clear_np();
  static const int kNpFieldNumber = 7;
  ::google::protobuf::int32 np() const;
  void set_np(::google::protobuf::int32 value);

  // optional int32 PNp = 8;
  bool has_pnp() const;
  void clear_pnp();
  static const int kPNpFieldNumber = 8;
  ::google::protobuf::int32 pnp() const;
  void set_pnp(::google::protobuf::int32 value);

  // optional int32 localPreKeyId = 11;
  bool has_localprekeyid() const;
  void clear_localprekeyid();
  static const int kLocalPreKeyIdFieldNumber = 11;
  ::google::protobuf::int32 localprekeyid() const;
  void set_localprekeyid(::google::protobuf::int32 value);

  // optional uint32 contextId2 = 15;
  bool has_contextid2() const;
  void clear_contextid2();
  static const int kContextId2FieldNumber = 15;
  ::google::protobuf::uint32 contextid2() const;
  void set_contextid2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zina.RatchetData)
 private:
  void set_has_useversion();
  void clear_has_useversion();
  void set_has_maxversion();
  void clear_has_maxversion();
  void set_has_contextid();
  void clear_has_contextid();
  void set_has_curvetype();
  void clear_has_curvetype();
  void set_has_flags();
  void clear_has_flags();
  void set_has_ratchetmsgtype();
  void clear_has_ratchetmsgtype();
  void set_has_np();
  void clear_has_np();
  void set_has_pnp();
  void clear_has_pnp();
  void set_has_ratchet();
  void clear_has_ratchet();
  void set_has_mac();
  void clear_has_mac();
  void set_has_localprekeyid();
  void clear_has_localprekeyid();
  void set_has_remoteprekey();
  void clear_has_remoteprekey();
  void set_has_remoteidkey();
  void clear_has_remoteidkey();
  void set_has_prekeyhash();
  void clear_has_prekeyhash();
  void set_has_contextid2();
  void clear_has_contextid2();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ratchet_;
  ::google::protobuf::internal::ArenaStringPtr mac_;
  ::google::protobuf::internal::ArenaStringPtr remoteprekey_;
  ::google::protobuf::internal::ArenaStringPtr remoteidkey_;
  ::google::protobuf::internal::ArenaStringPtr prekeyhash_;
  ::google::protobuf::int32 useversion_;
  ::google::protobuf::int32 maxversion_;
  ::google::protobuf::uint32 contextid_;
  ::google::protobuf::int32 curvetype_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::int32 ratchetmsgtype_;
  ::google::protobuf::int32 np_;
  ::google::protobuf::int32 pnp_;
  ::google::protobuf::int32 localprekeyid_;
  ::google::protobuf::uint32 contextid2_;
  friend struct ::protobuf_MessageEnvelope_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MessageEnvelope

// optional string name = 1;
inline bool MessageEnvelope::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageEnvelope::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageEnvelope::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageEnvelope::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MessageEnvelope::name() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.name)
  return name_.GetNoArena();
}
inline void MessageEnvelope::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.name)
}
#if LANG_CXX11
inline void MessageEnvelope::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.name)
}
#endif
inline void MessageEnvelope::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.name)
}
inline void MessageEnvelope::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.name)
}
inline ::std::string* MessageEnvelope::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_name() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.name)
}

// optional string scClientDevId = 2;
inline bool MessageEnvelope::has_scclientdevid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageEnvelope::set_has_scclientdevid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageEnvelope::clear_has_scclientdevid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageEnvelope::clear_scclientdevid() {
  scclientdevid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scclientdevid();
}
inline const ::std::string& MessageEnvelope::scclientdevid() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.scClientDevId)
  return scclientdevid_.GetNoArena();
}
inline void MessageEnvelope::set_scclientdevid(const ::std::string& value) {
  set_has_scclientdevid();
  scclientdevid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.scClientDevId)
}
#if LANG_CXX11
inline void MessageEnvelope::set_scclientdevid(::std::string&& value) {
  set_has_scclientdevid();
  scclientdevid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.scClientDevId)
}
#endif
inline void MessageEnvelope::set_scclientdevid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scclientdevid();
  scclientdevid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.scClientDevId)
}
inline void MessageEnvelope::set_scclientdevid(const char* value, size_t size) {
  set_has_scclientdevid();
  scclientdevid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.scClientDevId)
}
inline ::std::string* MessageEnvelope::mutable_scclientdevid() {
  set_has_scclientdevid();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.scClientDevId)
  return scclientdevid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_scclientdevid() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.scClientDevId)
  if (!has_scclientdevid()) {
    return NULL;
  }
  clear_has_scclientdevid();
  return scclientdevid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_scclientdevid(::std::string* scclientdevid) {
  if (scclientdevid != NULL) {
    set_has_scclientdevid();
  } else {
    clear_has_scclientdevid();
  }
  scclientdevid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scclientdevid);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.scClientDevId)
}

// optional uint32 msgType = 3;
inline bool MessageEnvelope::has_msgtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageEnvelope::set_has_msgtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessageEnvelope::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessageEnvelope::clear_msgtype() {
  msgtype_ = 0u;
  clear_has_msgtype();
}
inline ::google::protobuf::uint32 MessageEnvelope::msgtype() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.msgType)
  return msgtype_;
}
inline void MessageEnvelope::set_msgtype(::google::protobuf::uint32 value) {
  set_has_msgtype();
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.msgType)
}

// optional bytes supplement = 4;
inline bool MessageEnvelope::has_supplement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageEnvelope::set_has_supplement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageEnvelope::clear_has_supplement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageEnvelope::clear_supplement() {
  supplement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_supplement();
}
inline const ::std::string& MessageEnvelope::supplement() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.supplement)
  return supplement_.GetNoArena();
}
inline void MessageEnvelope::set_supplement(const ::std::string& value) {
  set_has_supplement();
  supplement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.supplement)
}
#if LANG_CXX11
inline void MessageEnvelope::set_supplement(::std::string&& value) {
  set_has_supplement();
  supplement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.supplement)
}
#endif
inline void MessageEnvelope::set_supplement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_supplement();
  supplement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.supplement)
}
inline void MessageEnvelope::set_supplement(const void* value, size_t size) {
  set_has_supplement();
  supplement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.supplement)
}
inline ::std::string* MessageEnvelope::mutable_supplement() {
  set_has_supplement();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.supplement)
  return supplement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_supplement() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.supplement)
  if (!has_supplement()) {
    return NULL;
  }
  clear_has_supplement();
  return supplement_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_supplement(::std::string* supplement) {
  if (supplement != NULL) {
    set_has_supplement();
  } else {
    clear_has_supplement();
  }
  supplement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), supplement);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.supplement)
}

// optional bytes message = 5;
inline bool MessageEnvelope::has_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageEnvelope::set_has_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageEnvelope::clear_has_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageEnvelope::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& MessageEnvelope::message() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.message)
  return message_.GetNoArena();
}
inline void MessageEnvelope::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.message)
}
#if LANG_CXX11
inline void MessageEnvelope::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.message)
}
#endif
inline void MessageEnvelope::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.message)
}
inline void MessageEnvelope::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.message)
}
inline ::std::string* MessageEnvelope::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_message() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.message)
}

// optional string msgId = 6;
inline bool MessageEnvelope::has_msgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageEnvelope::set_has_msgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageEnvelope::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageEnvelope::clear_msgid() {
  msgid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msgid();
}
inline const ::std::string& MessageEnvelope::msgid() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.msgId)
  return msgid_.GetNoArena();
}
inline void MessageEnvelope::set_msgid(const ::std::string& value) {
  set_has_msgid();
  msgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.msgId)
}
#if LANG_CXX11
inline void MessageEnvelope::set_msgid(::std::string&& value) {
  set_has_msgid();
  msgid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.msgId)
}
#endif
inline void MessageEnvelope::set_msgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msgid();
  msgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.msgId)
}
inline void MessageEnvelope::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  msgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.msgId)
}
inline ::std::string* MessageEnvelope::mutable_msgid() {
  set_has_msgid();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.msgId)
  return msgid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_msgid() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.msgId)
  if (!has_msgid()) {
    return NULL;
  }
  clear_has_msgid();
  return msgid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_msgid(::std::string* msgid) {
  if (msgid != NULL) {
    set_has_msgid();
  } else {
    clear_has_msgid();
  }
  msgid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msgid);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.msgId)
}

// optional bytes recvIdHash = 7;
inline bool MessageEnvelope::has_recvidhash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageEnvelope::set_has_recvidhash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageEnvelope::clear_has_recvidhash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageEnvelope::clear_recvidhash() {
  recvidhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recvidhash();
}
inline const ::std::string& MessageEnvelope::recvidhash() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.recvIdHash)
  return recvidhash_.GetNoArena();
}
inline void MessageEnvelope::set_recvidhash(const ::std::string& value) {
  set_has_recvidhash();
  recvidhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.recvIdHash)
}
#if LANG_CXX11
inline void MessageEnvelope::set_recvidhash(::std::string&& value) {
  set_has_recvidhash();
  recvidhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.recvIdHash)
}
#endif
inline void MessageEnvelope::set_recvidhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_recvidhash();
  recvidhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.recvIdHash)
}
inline void MessageEnvelope::set_recvidhash(const void* value, size_t size) {
  set_has_recvidhash();
  recvidhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.recvIdHash)
}
inline ::std::string* MessageEnvelope::mutable_recvidhash() {
  set_has_recvidhash();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.recvIdHash)
  return recvidhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_recvidhash() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.recvIdHash)
  if (!has_recvidhash()) {
    return NULL;
  }
  clear_has_recvidhash();
  return recvidhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_recvidhash(::std::string* recvidhash) {
  if (recvidhash != NULL) {
    set_has_recvidhash();
  } else {
    clear_has_recvidhash();
  }
  recvidhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recvidhash);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.recvIdHash)
}

// optional bytes senderIdHash = 8;
inline bool MessageEnvelope::has_senderidhash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageEnvelope::set_has_senderidhash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageEnvelope::clear_has_senderidhash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageEnvelope::clear_senderidhash() {
  senderidhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_senderidhash();
}
inline const ::std::string& MessageEnvelope::senderidhash() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.senderIdHash)
  return senderidhash_.GetNoArena();
}
inline void MessageEnvelope::set_senderidhash(const ::std::string& value) {
  set_has_senderidhash();
  senderidhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.senderIdHash)
}
#if LANG_CXX11
inline void MessageEnvelope::set_senderidhash(::std::string&& value) {
  set_has_senderidhash();
  senderidhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.senderIdHash)
}
#endif
inline void MessageEnvelope::set_senderidhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_senderidhash();
  senderidhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.senderIdHash)
}
inline void MessageEnvelope::set_senderidhash(const void* value, size_t size) {
  set_has_senderidhash();
  senderidhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.senderIdHash)
}
inline ::std::string* MessageEnvelope::mutable_senderidhash() {
  set_has_senderidhash();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.senderIdHash)
  return senderidhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_senderidhash() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.senderIdHash)
  if (!has_senderidhash()) {
    return NULL;
  }
  clear_has_senderidhash();
  return senderidhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_senderidhash(::std::string* senderidhash) {
  if (senderidhash != NULL) {
    set_has_senderidhash();
  } else {
    clear_has_senderidhash();
  }
  senderidhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), senderidhash);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.senderIdHash)
}

// optional bytes recvDevIdBin = 10;
inline bool MessageEnvelope::has_recvdevidbin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageEnvelope::set_has_recvdevidbin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageEnvelope::clear_has_recvdevidbin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageEnvelope::clear_recvdevidbin() {
  recvdevidbin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recvdevidbin();
}
inline const ::std::string& MessageEnvelope::recvdevidbin() const {
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.recvDevIdBin)
  return recvdevidbin_.GetNoArena();
}
inline void MessageEnvelope::set_recvdevidbin(const ::std::string& value) {
  set_has_recvdevidbin();
  recvdevidbin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.MessageEnvelope.recvDevIdBin)
}
#if LANG_CXX11
inline void MessageEnvelope::set_recvdevidbin(::std::string&& value) {
  set_has_recvdevidbin();
  recvdevidbin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.MessageEnvelope.recvDevIdBin)
}
#endif
inline void MessageEnvelope::set_recvdevidbin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_recvdevidbin();
  recvdevidbin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.MessageEnvelope.recvDevIdBin)
}
inline void MessageEnvelope::set_recvdevidbin(const void* value, size_t size) {
  set_has_recvdevidbin();
  recvdevidbin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.MessageEnvelope.recvDevIdBin)
}
inline ::std::string* MessageEnvelope::mutable_recvdevidbin() {
  set_has_recvdevidbin();
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.recvDevIdBin)
  return recvdevidbin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageEnvelope::release_recvdevidbin() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.recvDevIdBin)
  if (!has_recvdevidbin()) {
    return NULL;
  }
  clear_has_recvdevidbin();
  return recvdevidbin_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageEnvelope::set_allocated_recvdevidbin(::std::string* recvdevidbin) {
  if (recvdevidbin != NULL) {
    set_has_recvdevidbin();
  } else {
    clear_has_recvdevidbin();
  }
  recvdevidbin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recvdevidbin);
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.recvDevIdBin)
}

// optional .zina.RatchetData ratchet = 12;
inline bool MessageEnvelope::has_ratchet() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageEnvelope::set_has_ratchet() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MessageEnvelope::clear_has_ratchet() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MessageEnvelope::clear_ratchet() {
  if (ratchet_ != NULL) ratchet_->Clear();
  clear_has_ratchet();
}
inline const ::zina::RatchetData& MessageEnvelope::_internal_ratchet() const {
  return *ratchet_;
}
inline const ::zina::RatchetData& MessageEnvelope::ratchet() const {
  const ::zina::RatchetData* p = ratchet_;
  // @@protoc_insertion_point(field_get:zina.MessageEnvelope.ratchet)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::RatchetData*>(
      &::zina::_RatchetData_default_instance_);
}
inline ::zina::RatchetData* MessageEnvelope::release_ratchet() {
  // @@protoc_insertion_point(field_release:zina.MessageEnvelope.ratchet)
  clear_has_ratchet();
  ::zina::RatchetData* temp = ratchet_;
  ratchet_ = NULL;
  return temp;
}
inline ::zina::RatchetData* MessageEnvelope::mutable_ratchet() {
  set_has_ratchet();
  if (ratchet_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::RatchetData>(GetArenaNoVirtual());
    ratchet_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.MessageEnvelope.ratchet)
  return ratchet_;
}
inline void MessageEnvelope::set_allocated_ratchet(::zina::RatchetData* ratchet) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ratchet_;
  }
  if (ratchet) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ratchet = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ratchet, submessage_arena);
    }
    set_has_ratchet();
  } else {
    clear_has_ratchet();
  }
  ratchet_ = ratchet;
  // @@protoc_insertion_point(field_set_allocated:zina.MessageEnvelope.ratchet)
}

// -------------------------------------------------------------------

// RatchetData

// optional int32 useVersion = 1;
inline bool RatchetData::has_useversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RatchetData::set_has_useversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RatchetData::clear_has_useversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RatchetData::clear_useversion() {
  useversion_ = 0;
  clear_has_useversion();
}
inline ::google::protobuf::int32 RatchetData::useversion() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.useVersion)
  return useversion_;
}
inline void RatchetData::set_useversion(::google::protobuf::int32 value) {
  set_has_useversion();
  useversion_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.useVersion)
}

// optional int32 maxVersion = 2;
inline bool RatchetData::has_maxversion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RatchetData::set_has_maxversion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RatchetData::clear_has_maxversion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RatchetData::clear_maxversion() {
  maxversion_ = 0;
  clear_has_maxversion();
}
inline ::google::protobuf::int32 RatchetData::maxversion() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.maxVersion)
  return maxversion_;
}
inline void RatchetData::set_maxversion(::google::protobuf::int32 value) {
  set_has_maxversion();
  maxversion_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.maxVersion)
}

// optional uint32 contextId = 3;
inline bool RatchetData::has_contextid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RatchetData::set_has_contextid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RatchetData::clear_has_contextid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RatchetData::clear_contextid() {
  contextid_ = 0u;
  clear_has_contextid();
}
inline ::google::protobuf::uint32 RatchetData::contextid() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.contextId)
  return contextid_;
}
inline void RatchetData::set_contextid(::google::protobuf::uint32 value) {
  set_has_contextid();
  contextid_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.contextId)
}

// optional int32 curveType = 4;
inline bool RatchetData::has_curvetype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RatchetData::set_has_curvetype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RatchetData::clear_has_curvetype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RatchetData::clear_curvetype() {
  curvetype_ = 0;
  clear_has_curvetype();
}
inline ::google::protobuf::int32 RatchetData::curvetype() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.curveType)
  return curvetype_;
}
inline void RatchetData::set_curvetype(::google::protobuf::int32 value) {
  set_has_curvetype();
  curvetype_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.curveType)
}

// optional uint32 flags = 5;
inline bool RatchetData::has_flags() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RatchetData::set_has_flags() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RatchetData::clear_has_flags() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RatchetData::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 RatchetData::flags() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.flags)
  return flags_;
}
inline void RatchetData::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.flags)
}

// optional int32 ratchetMsgType = 6;
inline bool RatchetData::has_ratchetmsgtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RatchetData::set_has_ratchetmsgtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RatchetData::clear_has_ratchetmsgtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RatchetData::clear_ratchetmsgtype() {
  ratchetmsgtype_ = 0;
  clear_has_ratchetmsgtype();
}
inline ::google::protobuf::int32 RatchetData::ratchetmsgtype() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.ratchetMsgType)
  return ratchetmsgtype_;
}
inline void RatchetData::set_ratchetmsgtype(::google::protobuf::int32 value) {
  set_has_ratchetmsgtype();
  ratchetmsgtype_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.ratchetMsgType)
}

// optional int32 Np = 7;
inline bool RatchetData::has_np() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RatchetData::set_has_np() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RatchetData::clear_has_np() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RatchetData::clear_np() {
  np_ = 0;
  clear_has_np();
}
inline ::google::protobuf::int32 RatchetData::np() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.Np)
  return np_;
}
inline void RatchetData::set_np(::google::protobuf::int32 value) {
  set_has_np();
  np_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.Np)
}

// optional int32 PNp = 8;
inline bool RatchetData::has_pnp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RatchetData::set_has_pnp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RatchetData::clear_has_pnp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RatchetData::clear_pnp() {
  pnp_ = 0;
  clear_has_pnp();
}
inline ::google::protobuf::int32 RatchetData::pnp() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.PNp)
  return pnp_;
}
inline void RatchetData::set_pnp(::google::protobuf::int32 value) {
  set_has_pnp();
  pnp_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.PNp)
}

// optional bytes ratchet = 9;
inline bool RatchetData::has_ratchet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RatchetData::set_has_ratchet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RatchetData::clear_has_ratchet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RatchetData::clear_ratchet() {
  ratchet_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ratchet();
}
inline const ::std::string& RatchetData::ratchet() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.ratchet)
  return ratchet_.GetNoArena();
}
inline void RatchetData::set_ratchet(const ::std::string& value) {
  set_has_ratchet();
  ratchet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.ratchet)
}
#if LANG_CXX11
inline void RatchetData::set_ratchet(::std::string&& value) {
  set_has_ratchet();
  ratchet_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.RatchetData.ratchet)
}
#endif
inline void RatchetData::set_ratchet(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ratchet();
  ratchet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.ratchet)
}
inline void RatchetData::set_ratchet(const void* value, size_t size) {
  set_has_ratchet();
  ratchet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.ratchet)
}
inline ::std::string* RatchetData::mutable_ratchet() {
  set_has_ratchet();
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.ratchet)
  return ratchet_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatchetData::release_ratchet() {
  // @@protoc_insertion_point(field_release:zina.RatchetData.ratchet)
  if (!has_ratchet()) {
    return NULL;
  }
  clear_has_ratchet();
  return ratchet_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatchetData::set_allocated_ratchet(::std::string* ratchet) {
  if (ratchet != NULL) {
    set_has_ratchet();
  } else {
    clear_has_ratchet();
  }
  ratchet_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ratchet);
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.ratchet)
}

// optional bytes mac = 10;
inline bool RatchetData::has_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RatchetData::set_has_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RatchetData::clear_has_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RatchetData::clear_mac() {
  mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mac();
}
inline const ::std::string& RatchetData::mac() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.mac)
  return mac_.GetNoArena();
}
inline void RatchetData::set_mac(const ::std::string& value) {
  set_has_mac();
  mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.mac)
}
#if LANG_CXX11
inline void RatchetData::set_mac(::std::string&& value) {
  set_has_mac();
  mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.RatchetData.mac)
}
#endif
inline void RatchetData::set_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mac();
  mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.mac)
}
inline void RatchetData::set_mac(const void* value, size_t size) {
  set_has_mac();
  mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.mac)
}
inline ::std::string* RatchetData::mutable_mac() {
  set_has_mac();
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.mac)
  return mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatchetData::release_mac() {
  // @@protoc_insertion_point(field_release:zina.RatchetData.mac)
  if (!has_mac()) {
    return NULL;
  }
  clear_has_mac();
  return mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatchetData::set_allocated_mac(::std::string* mac) {
  if (mac != NULL) {
    set_has_mac();
  } else {
    clear_has_mac();
  }
  mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac);
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.mac)
}

// optional int32 localPreKeyId = 11;
inline bool RatchetData::has_localprekeyid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RatchetData::set_has_localprekeyid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RatchetData::clear_has_localprekeyid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RatchetData::clear_localprekeyid() {
  localprekeyid_ = 0;
  clear_has_localprekeyid();
}
inline ::google::protobuf::int32 RatchetData::localprekeyid() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.localPreKeyId)
  return localprekeyid_;
}
inline void RatchetData::set_localprekeyid(::google::protobuf::int32 value) {
  set_has_localprekeyid();
  localprekeyid_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.localPreKeyId)
}

// optional bytes remotePreKey = 12;
inline bool RatchetData::has_remoteprekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RatchetData::set_has_remoteprekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RatchetData::clear_has_remoteprekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RatchetData::clear_remoteprekey() {
  remoteprekey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_remoteprekey();
}
inline const ::std::string& RatchetData::remoteprekey() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.remotePreKey)
  return remoteprekey_.GetNoArena();
}
inline void RatchetData::set_remoteprekey(const ::std::string& value) {
  set_has_remoteprekey();
  remoteprekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.remotePreKey)
}
#if LANG_CXX11
inline void RatchetData::set_remoteprekey(::std::string&& value) {
  set_has_remoteprekey();
  remoteprekey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.RatchetData.remotePreKey)
}
#endif
inline void RatchetData::set_remoteprekey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_remoteprekey();
  remoteprekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.remotePreKey)
}
inline void RatchetData::set_remoteprekey(const void* value, size_t size) {
  set_has_remoteprekey();
  remoteprekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.remotePreKey)
}
inline ::std::string* RatchetData::mutable_remoteprekey() {
  set_has_remoteprekey();
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.remotePreKey)
  return remoteprekey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatchetData::release_remoteprekey() {
  // @@protoc_insertion_point(field_release:zina.RatchetData.remotePreKey)
  if (!has_remoteprekey()) {
    return NULL;
  }
  clear_has_remoteprekey();
  return remoteprekey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatchetData::set_allocated_remoteprekey(::std::string* remoteprekey) {
  if (remoteprekey != NULL) {
    set_has_remoteprekey();
  } else {
    clear_has_remoteprekey();
  }
  remoteprekey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remoteprekey);
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.remotePreKey)
}

// optional bytes remoteIdKey = 13;
inline bool RatchetData::has_remoteidkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RatchetData::set_has_remoteidkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RatchetData::clear_has_remoteidkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RatchetData::clear_remoteidkey() {
  remoteidkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_remoteidkey();
}
inline const ::std::string& RatchetData::remoteidkey() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.remoteIdKey)
  return remoteidkey_.GetNoArena();
}
inline void RatchetData::set_remoteidkey(const ::std::string& value) {
  set_has_remoteidkey();
  remoteidkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.remoteIdKey)
}
#if LANG_CXX11
inline void RatchetData::set_remoteidkey(::std::string&& value) {
  set_has_remoteidkey();
  remoteidkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.RatchetData.remoteIdKey)
}
#endif
inline void RatchetData::set_remoteidkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_remoteidkey();
  remoteidkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.remoteIdKey)
}
inline void RatchetData::set_remoteidkey(const void* value, size_t size) {
  set_has_remoteidkey();
  remoteidkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.remoteIdKey)
}
inline ::std::string* RatchetData::mutable_remoteidkey() {
  set_has_remoteidkey();
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.remoteIdKey)
  return remoteidkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatchetData::release_remoteidkey() {
  // @@protoc_insertion_point(field_release:zina.RatchetData.remoteIdKey)
  if (!has_remoteidkey()) {
    return NULL;
  }
  clear_has_remoteidkey();
  return remoteidkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatchetData::set_allocated_remoteidkey(::std::string* remoteidkey) {
  if (remoteidkey != NULL) {
    set_has_remoteidkey();
  } else {
    clear_has_remoteidkey();
  }
  remoteidkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remoteidkey);
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.remoteIdKey)
}

// optional bytes preKeyHash = 14;
inline bool RatchetData::has_prekeyhash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RatchetData::set_has_prekeyhash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RatchetData::clear_has_prekeyhash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RatchetData::clear_prekeyhash() {
  prekeyhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prekeyhash();
}
inline const ::std::string& RatchetData::prekeyhash() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.preKeyHash)
  return prekeyhash_.GetNoArena();
}
inline void RatchetData::set_prekeyhash(const ::std::string& value) {
  set_has_prekeyhash();
  prekeyhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.RatchetData.preKeyHash)
}
#if LANG_CXX11
inline void RatchetData::set_prekeyhash(::std::string&& value) {
  set_has_prekeyhash();
  prekeyhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.RatchetData.preKeyHash)
}
#endif
inline void RatchetData::set_prekeyhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prekeyhash();
  prekeyhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.RatchetData.preKeyHash)
}
inline void RatchetData::set_prekeyhash(const void* value, size_t size) {
  set_has_prekeyhash();
  prekeyhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.RatchetData.preKeyHash)
}
inline ::std::string* RatchetData::mutable_prekeyhash() {
  set_has_prekeyhash();
  // @@protoc_insertion_point(field_mutable:zina.RatchetData.preKeyHash)
  return prekeyhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatchetData::release_prekeyhash() {
  // @@protoc_insertion_point(field_release:zina.RatchetData.preKeyHash)
  if (!has_prekeyhash()) {
    return NULL;
  }
  clear_has_prekeyhash();
  return prekeyhash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatchetData::set_allocated_prekeyhash(::std::string* prekeyhash) {
  if (prekeyhash != NULL) {
    set_has_prekeyhash();
  } else {
    clear_has_prekeyhash();
  }
  prekeyhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prekeyhash);
  // @@protoc_insertion_point(field_set_allocated:zina.RatchetData.preKeyHash)
}

// optional uint32 contextId2 = 15;
inline bool RatchetData::has_contextid2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RatchetData::set_has_contextid2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RatchetData::clear_has_contextid2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RatchetData::clear_contextid2() {
  contextid2_ = 0u;
  clear_has_contextid2();
}
inline ::google::protobuf::uint32 RatchetData::contextid2() const {
  // @@protoc_insertion_point(field_get:zina.RatchetData.contextId2)
  return contextid2_;
}
inline void RatchetData::set_contextid2(::google::protobuf::uint32 value) {
  set_has_contextid2();
  contextid2_ = value;
  // @@protoc_insertion_point(field_set:zina.RatchetData.contextId2)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zina

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_MessageEnvelope_2eproto
