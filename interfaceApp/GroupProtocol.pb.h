// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GroupProtocol.proto

#ifndef PROTOBUF_INCLUDED_GroupProtocol_2eproto
#define PROTOBUF_INCLUDED_GroupProtocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_GroupProtocol_2eproto 

namespace protobuf_GroupProtocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_GroupProtocol_2eproto
namespace zina {
class GroupBurnMessage;
class GroupBurnMessageDefaultTypeInternal;
extern GroupBurnMessageDefaultTypeInternal _GroupBurnMessage_default_instance_;
class GroupChangeSet;
class GroupChangeSetDefaultTypeInternal;
extern GroupChangeSetDefaultTypeInternal _GroupChangeSet_default_instance_;
class GroupUpdateAck;
class GroupUpdateAckDefaultTypeInternal;
extern GroupUpdateAckDefaultTypeInternal _GroupUpdateAck_default_instance_;
class GroupUpdateAddMember;
class GroupUpdateAddMemberDefaultTypeInternal;
extern GroupUpdateAddMemberDefaultTypeInternal _GroupUpdateAddMember_default_instance_;
class GroupUpdateRmMember;
class GroupUpdateRmMemberDefaultTypeInternal;
extern GroupUpdateRmMemberDefaultTypeInternal _GroupUpdateRmMember_default_instance_;
class GroupUpdateSetAvatar;
class GroupUpdateSetAvatarDefaultTypeInternal;
extern GroupUpdateSetAvatarDefaultTypeInternal _GroupUpdateSetAvatar_default_instance_;
class GroupUpdateSetBurn;
class GroupUpdateSetBurnDefaultTypeInternal;
extern GroupUpdateSetBurnDefaultTypeInternal _GroupUpdateSetBurn_default_instance_;
class GroupUpdateSetName;
class GroupUpdateSetNameDefaultTypeInternal;
extern GroupUpdateSetNameDefaultTypeInternal _GroupUpdateSetName_default_instance_;
class LocalVClock;
class LocalVClockDefaultTypeInternal;
extern LocalVClockDefaultTypeInternal _LocalVClock_default_instance_;
class Member;
class MemberDefaultTypeInternal;
extern MemberDefaultTypeInternal _Member_default_instance_;
class VClock;
class VClockDefaultTypeInternal;
extern VClockDefaultTypeInternal _VClock_default_instance_;
}  // namespace zina
namespace google {
namespace protobuf {
template<> ::zina::GroupBurnMessage* Arena::CreateMaybeMessage<::zina::GroupBurnMessage>(Arena*);
template<> ::zina::GroupChangeSet* Arena::CreateMaybeMessage<::zina::GroupChangeSet>(Arena*);
template<> ::zina::GroupUpdateAck* Arena::CreateMaybeMessage<::zina::GroupUpdateAck>(Arena*);
template<> ::zina::GroupUpdateAddMember* Arena::CreateMaybeMessage<::zina::GroupUpdateAddMember>(Arena*);
template<> ::zina::GroupUpdateRmMember* Arena::CreateMaybeMessage<::zina::GroupUpdateRmMember>(Arena*);
template<> ::zina::GroupUpdateSetAvatar* Arena::CreateMaybeMessage<::zina::GroupUpdateSetAvatar>(Arena*);
template<> ::zina::GroupUpdateSetBurn* Arena::CreateMaybeMessage<::zina::GroupUpdateSetBurn>(Arena*);
template<> ::zina::GroupUpdateSetName* Arena::CreateMaybeMessage<::zina::GroupUpdateSetName>(Arena*);
template<> ::zina::LocalVClock* Arena::CreateMaybeMessage<::zina::LocalVClock>(Arena*);
template<> ::zina::Member* Arena::CreateMaybeMessage<::zina::Member>(Arena*);
template<> ::zina::VClock* Arena::CreateMaybeMessage<::zina::VClock>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zina {

enum GroupUpdateSetBurn_BurnMode {
  GroupUpdateSetBurn_BurnMode_BURN_NONE = 0,
  GroupUpdateSetBurn_BurnMode_FROM_SEND_RETROACTIVE = 1
};
bool GroupUpdateSetBurn_BurnMode_IsValid(int value);
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn_BurnMode_BurnMode_MIN = GroupUpdateSetBurn_BurnMode_BURN_NONE;
const GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn_BurnMode_BurnMode_MAX = GroupUpdateSetBurn_BurnMode_FROM_SEND_RETROACTIVE;
const int GroupUpdateSetBurn_BurnMode_BurnMode_ARRAYSIZE = GroupUpdateSetBurn_BurnMode_BurnMode_MAX + 1;

enum GroupUpdateType {
  TYPE_NONE = 0,
  GROUP_SET_NAME = 1,
  GROUP_SET_AVATAR = 2,
  GROUP_SET_BURN = 3,
  GROUP_ADD_MEMBER = 4,
  GROUP_REMOVE_MEMBER = 5,
  GROUP_BURN_MESSSAGE = 6
};
bool GroupUpdateType_IsValid(int value);
const GroupUpdateType GroupUpdateType_MIN = TYPE_NONE;
const GroupUpdateType GroupUpdateType_MAX = GROUP_BURN_MESSSAGE;
const int GroupUpdateType_ARRAYSIZE = GroupUpdateType_MAX + 1;

enum GroupUpdateResult {
  RESULT_NONE = 0,
  ACCEPTED_OK = 1,
  ACCEPTED_CONFLICT = 2,
  REJECTED_NOP = 3,
  REJECTED_PAST = 4,
  REJECTED_CONFLICT = 5
};
bool GroupUpdateResult_IsValid(int value);
const GroupUpdateResult GroupUpdateResult_MIN = RESULT_NONE;
const GroupUpdateResult GroupUpdateResult_MAX = REJECTED_CONFLICT;
const int GroupUpdateResult_ARRAYSIZE = GroupUpdateResult_MAX + 1;

// ===================================================================

class VClock : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.VClock) */ {
 public:
  VClock();
  virtual ~VClock();

  VClock(const VClock& from);

  inline VClock& operator=(const VClock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VClock(VClock&& from) noexcept
    : VClock() {
    *this = ::std::move(from);
  }

  inline VClock& operator=(VClock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VClock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VClock* internal_default_instance() {
    return reinterpret_cast<const VClock*>(
               &_VClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(VClock* other);
  friend void swap(VClock& a, VClock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VClock* New() const final {
    return CreateMaybeMessage<VClock>(NULL);
  }

  VClock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VClock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VClock& from);
  void MergeFrom(const VClock& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VClock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes device_id = 1;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  const ::std::string& device_id() const;
  void set_device_id(const ::std::string& value);
  #if LANG_CXX11
  void set_device_id(::std::string&& value);
  #endif
  void set_device_id(const char* value);
  void set_device_id(const void* value, size_t size);
  ::std::string* mutable_device_id();
  ::std::string* release_device_id();
  void set_allocated_device_id(::std::string* device_id);

  // optional int64 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:zina.VClock)
 private:
  void set_has_device_id();
  void clear_has_device_id();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr device_id_;
  ::google::protobuf::int64 value_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalVClock : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.LocalVClock) */ {
 public:
  LocalVClock();
  virtual ~LocalVClock();

  LocalVClock(const LocalVClock& from);

  inline LocalVClock& operator=(const LocalVClock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalVClock(LocalVClock&& from) noexcept
    : LocalVClock() {
    *this = ::std::move(from);
  }

  inline LocalVClock& operator=(LocalVClock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LocalVClock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalVClock* internal_default_instance() {
    return reinterpret_cast<const LocalVClock*>(
               &_LocalVClock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LocalVClock* other);
  friend void swap(LocalVClock& a, LocalVClock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalVClock* New() const final {
    return CreateMaybeMessage<LocalVClock>(NULL);
  }

  LocalVClock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalVClock>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const LocalVClock& from);
  void MergeFrom(const LocalVClock& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalVClock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.VClock vclock = 1;
  int vclock_size() const;
  void clear_vclock();
  static const int kVclockFieldNumber = 1;
  ::zina::VClock* mutable_vclock(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();
  const ::zina::VClock& vclock(int index) const;
  ::zina::VClock* add_vclock();
  const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;

  // optional bytes update_id = 2;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 2;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // @@protoc_insertion_point(class_scope:zina.LocalVClock)
 private:
  void set_has_update_id();
  void clear_has_update_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.Member) */ {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Member(Member&& from) noexcept
    : Member() {
    *this = ::std::move(from);
  }

  inline Member& operator=(Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Member* internal_default_instance() {
    return reinterpret_cast<const Member*>(
               &_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Member* other);
  friend void swap(Member& a, Member& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Member* New() const final {
    return CreateMaybeMessage<Member>(NULL);
  }

  Member* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Member>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Member* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:zina.Member)
 private:
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUpdateSetName : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupUpdateSetName) */ {
 public:
  GroupUpdateSetName();
  virtual ~GroupUpdateSetName();

  GroupUpdateSetName(const GroupUpdateSetName& from);

  inline GroupUpdateSetName& operator=(const GroupUpdateSetName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUpdateSetName(GroupUpdateSetName&& from) noexcept
    : GroupUpdateSetName() {
    *this = ::std::move(from);
  }

  inline GroupUpdateSetName& operator=(GroupUpdateSetName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupUpdateSetName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUpdateSetName* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateSetName*>(
               &_GroupUpdateSetName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GroupUpdateSetName* other);
  friend void swap(GroupUpdateSetName& a, GroupUpdateSetName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUpdateSetName* New() const final {
    return CreateMaybeMessage<GroupUpdateSetName>(NULL);
  }

  GroupUpdateSetName* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUpdateSetName>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupUpdateSetName& from);
  void MergeFrom(const GroupUpdateSetName& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUpdateSetName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.VClock vclock = 2;
  int vclock_size() const;
  void clear_vclock();
  static const int kVclockFieldNumber = 2;
  ::zina::VClock* mutable_vclock(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();
  const ::zina::VClock& vclock(int index) const;
  ::zina::VClock* add_vclock();
  const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;

  // optional bytes update_id = 1;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string user_id = 4;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateSetName)
 private:
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_name();
  void clear_has_name();
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUpdateSetAvatar : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupUpdateSetAvatar) */ {
 public:
  GroupUpdateSetAvatar();
  virtual ~GroupUpdateSetAvatar();

  GroupUpdateSetAvatar(const GroupUpdateSetAvatar& from);

  inline GroupUpdateSetAvatar& operator=(const GroupUpdateSetAvatar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUpdateSetAvatar(GroupUpdateSetAvatar&& from) noexcept
    : GroupUpdateSetAvatar() {
    *this = ::std::move(from);
  }

  inline GroupUpdateSetAvatar& operator=(GroupUpdateSetAvatar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupUpdateSetAvatar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUpdateSetAvatar* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateSetAvatar*>(
               &_GroupUpdateSetAvatar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GroupUpdateSetAvatar* other);
  friend void swap(GroupUpdateSetAvatar& a, GroupUpdateSetAvatar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUpdateSetAvatar* New() const final {
    return CreateMaybeMessage<GroupUpdateSetAvatar>(NULL);
  }

  GroupUpdateSetAvatar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUpdateSetAvatar>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupUpdateSetAvatar& from);
  void MergeFrom(const GroupUpdateSetAvatar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUpdateSetAvatar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.VClock vclock = 2;
  int vclock_size() const;
  void clear_vclock();
  static const int kVclockFieldNumber = 2;
  ::zina::VClock* mutable_vclock(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();
  const ::zina::VClock& vclock(int index) const;
  ::zina::VClock* add_vclock();
  const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;

  // optional bytes update_id = 1;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional string avatar = 3;
  bool has_avatar() const;
  void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  const ::std::string& avatar() const;
  void set_avatar(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar(::std::string&& value);
  #endif
  void set_avatar(const char* value);
  void set_avatar(const char* value, size_t size);
  ::std::string* mutable_avatar();
  ::std::string* release_avatar();
  void set_allocated_avatar(::std::string* avatar);

  // optional string user_id = 4;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateSetAvatar)
 private:
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_avatar();
  void clear_has_avatar();
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  ::google::protobuf::internal::ArenaStringPtr avatar_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUpdateSetBurn : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupUpdateSetBurn) */ {
 public:
  GroupUpdateSetBurn();
  virtual ~GroupUpdateSetBurn();

  GroupUpdateSetBurn(const GroupUpdateSetBurn& from);

  inline GroupUpdateSetBurn& operator=(const GroupUpdateSetBurn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUpdateSetBurn(GroupUpdateSetBurn&& from) noexcept
    : GroupUpdateSetBurn() {
    *this = ::std::move(from);
  }

  inline GroupUpdateSetBurn& operator=(GroupUpdateSetBurn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupUpdateSetBurn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUpdateSetBurn* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateSetBurn*>(
               &_GroupUpdateSetBurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GroupUpdateSetBurn* other);
  friend void swap(GroupUpdateSetBurn& a, GroupUpdateSetBurn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUpdateSetBurn* New() const final {
    return CreateMaybeMessage<GroupUpdateSetBurn>(NULL);
  }

  GroupUpdateSetBurn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUpdateSetBurn>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupUpdateSetBurn& from);
  void MergeFrom(const GroupUpdateSetBurn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUpdateSetBurn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef GroupUpdateSetBurn_BurnMode BurnMode;
  static const BurnMode BURN_NONE =
    GroupUpdateSetBurn_BurnMode_BURN_NONE;
  static const BurnMode FROM_SEND_RETROACTIVE =
    GroupUpdateSetBurn_BurnMode_FROM_SEND_RETROACTIVE;
  static inline bool BurnMode_IsValid(int value) {
    return GroupUpdateSetBurn_BurnMode_IsValid(value);
  }
  static const BurnMode BurnMode_MIN =
    GroupUpdateSetBurn_BurnMode_BurnMode_MIN;
  static const BurnMode BurnMode_MAX =
    GroupUpdateSetBurn_BurnMode_BurnMode_MAX;
  static const int BurnMode_ARRAYSIZE =
    GroupUpdateSetBurn_BurnMode_BurnMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .zina.VClock vclock = 2;
  int vclock_size() const;
  void clear_vclock();
  static const int kVclockFieldNumber = 2;
  ::zina::VClock* mutable_vclock(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
      mutable_vclock();
  const ::zina::VClock& vclock(int index) const;
  ::zina::VClock* add_vclock();
  const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
      vclock() const;

  // optional bytes update_id = 1;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional string user_id = 5;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional uint64 burn_ttl_sec = 4;
  bool has_burn_ttl_sec() const;
  void clear_burn_ttl_sec();
  static const int kBurnTtlSecFieldNumber = 4;
  ::google::protobuf::uint64 burn_ttl_sec() const;
  void set_burn_ttl_sec(::google::protobuf::uint64 value);

  // optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
  bool has_burn_mode() const;
  void clear_burn_mode();
  static const int kBurnModeFieldNumber = 3;
  ::zina::GroupUpdateSetBurn_BurnMode burn_mode() const;
  void set_burn_mode(::zina::GroupUpdateSetBurn_BurnMode value);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateSetBurn)
 private:
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_burn_mode();
  void clear_has_burn_mode();
  void set_has_burn_ttl_sec();
  void clear_has_burn_ttl_sec();
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::VClock > vclock_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::uint64 burn_ttl_sec_;
  int burn_mode_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUpdateAddMember : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupUpdateAddMember) */ {
 public:
  GroupUpdateAddMember();
  virtual ~GroupUpdateAddMember();

  GroupUpdateAddMember(const GroupUpdateAddMember& from);

  inline GroupUpdateAddMember& operator=(const GroupUpdateAddMember& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUpdateAddMember(GroupUpdateAddMember&& from) noexcept
    : GroupUpdateAddMember() {
    *this = ::std::move(from);
  }

  inline GroupUpdateAddMember& operator=(GroupUpdateAddMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupUpdateAddMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUpdateAddMember* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateAddMember*>(
               &_GroupUpdateAddMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GroupUpdateAddMember* other);
  friend void swap(GroupUpdateAddMember& a, GroupUpdateAddMember& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUpdateAddMember* New() const final {
    return CreateMaybeMessage<GroupUpdateAddMember>(NULL);
  }

  GroupUpdateAddMember* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUpdateAddMember>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupUpdateAddMember& from);
  void MergeFrom(const GroupUpdateAddMember& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUpdateAddMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.Member addMember = 2;
  int addmember_size() const;
  void clear_addmember();
  static const int kAddMemberFieldNumber = 2;
  ::zina::Member* mutable_addmember(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::Member >*
      mutable_addmember();
  const ::zina::Member& addmember(int index) const;
  ::zina::Member* add_addmember();
  const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
      addmember() const;

  // optional bytes update_id = 1;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional string user_id = 3;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateAddMember)
 private:
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::Member > addmember_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUpdateRmMember : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupUpdateRmMember) */ {
 public:
  GroupUpdateRmMember();
  virtual ~GroupUpdateRmMember();

  GroupUpdateRmMember(const GroupUpdateRmMember& from);

  inline GroupUpdateRmMember& operator=(const GroupUpdateRmMember& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUpdateRmMember(GroupUpdateRmMember&& from) noexcept
    : GroupUpdateRmMember() {
    *this = ::std::move(from);
  }

  inline GroupUpdateRmMember& operator=(GroupUpdateRmMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupUpdateRmMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUpdateRmMember* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateRmMember*>(
               &_GroupUpdateRmMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GroupUpdateRmMember* other);
  friend void swap(GroupUpdateRmMember& a, GroupUpdateRmMember& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUpdateRmMember* New() const final {
    return CreateMaybeMessage<GroupUpdateRmMember>(NULL);
  }

  GroupUpdateRmMember* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUpdateRmMember>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupUpdateRmMember& from);
  void MergeFrom(const GroupUpdateRmMember& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUpdateRmMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.Member rmMember = 2;
  int rmmember_size() const;
  void clear_rmmember();
  static const int kRmMemberFieldNumber = 2;
  ::zina::Member* mutable_rmmember(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::Member >*
      mutable_rmmember();
  const ::zina::Member& rmmember(int index) const;
  ::zina::Member* add_rmmember();
  const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
      rmmember() const;

  // optional bytes update_id = 1;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional string user_id = 3;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateRmMember)
 private:
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_user_id();
  void clear_has_user_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::Member > rmmember_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBurnMessage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupBurnMessage) */ {
 public:
  GroupBurnMessage();
  virtual ~GroupBurnMessage();

  GroupBurnMessage(const GroupBurnMessage& from);

  inline GroupBurnMessage& operator=(const GroupBurnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBurnMessage(GroupBurnMessage&& from) noexcept
    : GroupBurnMessage() {
    *this = ::std::move(from);
  }

  inline GroupBurnMessage& operator=(GroupBurnMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupBurnMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBurnMessage* internal_default_instance() {
    return reinterpret_cast<const GroupBurnMessage*>(
               &_GroupBurnMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GroupBurnMessage* other);
  friend void swap(GroupBurnMessage& a, GroupBurnMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBurnMessage* New() const final {
    return CreateMaybeMessage<GroupBurnMessage>(NULL);
  }

  GroupBurnMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBurnMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupBurnMessage& from);
  void MergeFrom(const GroupBurnMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupBurnMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string msgId = 2;
  int msgid_size() const;
  void clear_msgid();
  static const int kMsgIdFieldNumber = 2;
  const ::std::string& msgid(int index) const;
  ::std::string* mutable_msgid(int index);
  void set_msgid(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_msgid(int index, ::std::string&& value);
  #endif
  void set_msgid(int index, const char* value);
  void set_msgid(int index, const char* value, size_t size);
  ::std::string* add_msgid();
  void add_msgid(const ::std::string& value);
  #if LANG_CXX11
  void add_msgid(::std::string&& value);
  #endif
  void add_msgid(const char* value);
  void add_msgid(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& msgid() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msgid();

  // optional bytes update_id = 1;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 1;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional .zina.Member member = 3;
  bool has_member() const;
  void clear_member();
  static const int kMemberFieldNumber = 3;
  private:
  const ::zina::Member& _internal_member() const;
  public:
  const ::zina::Member& member() const;
  ::zina::Member* release_member();
  ::zina::Member* mutable_member();
  void set_allocated_member(::zina::Member* member);

  // @@protoc_insertion_point(class_scope:zina.GroupBurnMessage)
 private:
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_member();
  void clear_has_member();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> msgid_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  ::zina::Member* member_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupUpdateAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupUpdateAck) */ {
 public:
  GroupUpdateAck();
  virtual ~GroupUpdateAck();

  GroupUpdateAck(const GroupUpdateAck& from);

  inline GroupUpdateAck& operator=(const GroupUpdateAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupUpdateAck(GroupUpdateAck&& from) noexcept
    : GroupUpdateAck() {
    *this = ::std::move(from);
  }

  inline GroupUpdateAck& operator=(GroupUpdateAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupUpdateAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupUpdateAck* internal_default_instance() {
    return reinterpret_cast<const GroupUpdateAck*>(
               &_GroupUpdateAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GroupUpdateAck* other);
  friend void swap(GroupUpdateAck& a, GroupUpdateAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupUpdateAck* New() const final {
    return CreateMaybeMessage<GroupUpdateAck>(NULL);
  }

  GroupUpdateAck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupUpdateAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupUpdateAck& from);
  void MergeFrom(const GroupUpdateAck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupUpdateAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes update_id = 2;
  bool has_update_id() const;
  void clear_update_id();
  static const int kUpdateIdFieldNumber = 2;
  const ::std::string& update_id() const;
  void set_update_id(const ::std::string& value);
  #if LANG_CXX11
  void set_update_id(::std::string&& value);
  #endif
  void set_update_id(const char* value);
  void set_update_id(const void* value, size_t size);
  ::std::string* mutable_update_id();
  ::std::string* release_update_id();
  void set_allocated_update_id(::std::string* update_id);

  // optional .zina.GroupUpdateType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::zina::GroupUpdateType type() const;
  void set_type(::zina::GroupUpdateType value);

  // optional .zina.GroupUpdateResult result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::zina::GroupUpdateResult result() const;
  void set_result(::zina::GroupUpdateResult value);

  // @@protoc_insertion_point(class_scope:zina.GroupUpdateAck)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_update_id();
  void clear_has_update_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr update_id_;
  int type_;
  int result_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupChangeSet : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:zina.GroupChangeSet) */ {
 public:
  GroupChangeSet();
  virtual ~GroupChangeSet();

  GroupChangeSet(const GroupChangeSet& from);

  inline GroupChangeSet& operator=(const GroupChangeSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupChangeSet(GroupChangeSet&& from) noexcept
    : GroupChangeSet() {
    *this = ::std::move(from);
  }

  inline GroupChangeSet& operator=(GroupChangeSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupChangeSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupChangeSet* internal_default_instance() {
    return reinterpret_cast<const GroupChangeSet*>(
               &_GroupChangeSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GroupChangeSet* other);
  friend void swap(GroupChangeSet& a, GroupChangeSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupChangeSet* New() const final {
    return CreateMaybeMessage<GroupChangeSet>(NULL);
  }

  GroupChangeSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupChangeSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupChangeSet& from);
  void MergeFrom(const GroupChangeSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupChangeSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zina.GroupUpdateAck acks = 7;
  int acks_size() const;
  void clear_acks();
  static const int kAcksFieldNumber = 7;
  ::zina::GroupUpdateAck* mutable_acks(int index);
  ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >*
      mutable_acks();
  const ::zina::GroupUpdateAck& acks(int index) const;
  ::zina::GroupUpdateAck* add_acks();
  const ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >&
      acks() const;

  // optional bytes group_id = 1;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const void* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // optional .zina.GroupUpdateSetName updateName = 2;
  bool has_updatename() const;
  void clear_updatename();
  static const int kUpdateNameFieldNumber = 2;
  private:
  const ::zina::GroupUpdateSetName& _internal_updatename() const;
  public:
  const ::zina::GroupUpdateSetName& updatename() const;
  ::zina::GroupUpdateSetName* release_updatename();
  ::zina::GroupUpdateSetName* mutable_updatename();
  void set_allocated_updatename(::zina::GroupUpdateSetName* updatename);

  // optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
  bool has_updateavatar() const;
  void clear_updateavatar();
  static const int kUpdateAvatarFieldNumber = 3;
  private:
  const ::zina::GroupUpdateSetAvatar& _internal_updateavatar() const;
  public:
  const ::zina::GroupUpdateSetAvatar& updateavatar() const;
  ::zina::GroupUpdateSetAvatar* release_updateavatar();
  ::zina::GroupUpdateSetAvatar* mutable_updateavatar();
  void set_allocated_updateavatar(::zina::GroupUpdateSetAvatar* updateavatar);

  // optional .zina.GroupUpdateSetBurn updateBurn = 4;
  bool has_updateburn() const;
  void clear_updateburn();
  static const int kUpdateBurnFieldNumber = 4;
  private:
  const ::zina::GroupUpdateSetBurn& _internal_updateburn() const;
  public:
  const ::zina::GroupUpdateSetBurn& updateburn() const;
  ::zina::GroupUpdateSetBurn* release_updateburn();
  ::zina::GroupUpdateSetBurn* mutable_updateburn();
  void set_allocated_updateburn(::zina::GroupUpdateSetBurn* updateburn);

  // optional .zina.GroupUpdateAddMember updateAddMember = 5;
  bool has_updateaddmember() const;
  void clear_updateaddmember();
  static const int kUpdateAddMemberFieldNumber = 5;
  private:
  const ::zina::GroupUpdateAddMember& _internal_updateaddmember() const;
  public:
  const ::zina::GroupUpdateAddMember& updateaddmember() const;
  ::zina::GroupUpdateAddMember* release_updateaddmember();
  ::zina::GroupUpdateAddMember* mutable_updateaddmember();
  void set_allocated_updateaddmember(::zina::GroupUpdateAddMember* updateaddmember);

  // optional .zina.GroupUpdateRmMember updateRmMember = 6;
  bool has_updatermmember() const;
  void clear_updatermmember();
  static const int kUpdateRmMemberFieldNumber = 6;
  private:
  const ::zina::GroupUpdateRmMember& _internal_updatermmember() const;
  public:
  const ::zina::GroupUpdateRmMember& updatermmember() const;
  ::zina::GroupUpdateRmMember* release_updatermmember();
  ::zina::GroupUpdateRmMember* mutable_updatermmember();
  void set_allocated_updatermmember(::zina::GroupUpdateRmMember* updatermmember);

  // optional .zina.GroupBurnMessage burnMessage = 8;
  bool has_burnmessage() const;
  void clear_burnmessage();
  static const int kBurnMessageFieldNumber = 8;
  private:
  const ::zina::GroupBurnMessage& _internal_burnmessage() const;
  public:
  const ::zina::GroupBurnMessage& burnmessage() const;
  ::zina::GroupBurnMessage* release_burnmessage();
  ::zina::GroupBurnMessage* mutable_burnmessage();
  void set_allocated_burnmessage(::zina::GroupBurnMessage* burnmessage);

  // @@protoc_insertion_point(class_scope:zina.GroupChangeSet)
 private:
  void set_has_group_id();
  void clear_has_group_id();
  void set_has_updatename();
  void clear_has_updatename();
  void set_has_updateavatar();
  void clear_has_updateavatar();
  void set_has_updateburn();
  void clear_has_updateburn();
  void set_has_updateaddmember();
  void clear_has_updateaddmember();
  void set_has_updatermmember();
  void clear_has_updatermmember();
  void set_has_burnmessage();
  void clear_has_burnmessage();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck > acks_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::zina::GroupUpdateSetName* updatename_;
  ::zina::GroupUpdateSetAvatar* updateavatar_;
  ::zina::GroupUpdateSetBurn* updateburn_;
  ::zina::GroupUpdateAddMember* updateaddmember_;
  ::zina::GroupUpdateRmMember* updatermmember_;
  ::zina::GroupBurnMessage* burnmessage_;
  friend struct ::protobuf_GroupProtocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VClock

// optional bytes device_id = 1;
inline bool VClock::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VClock::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VClock::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VClock::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_id();
}
inline const ::std::string& VClock::device_id() const {
  // @@protoc_insertion_point(field_get:zina.VClock.device_id)
  return device_id_.GetNoArena();
}
inline void VClock::set_device_id(const ::std::string& value) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.VClock.device_id)
}
#if LANG_CXX11
inline void VClock::set_device_id(::std::string&& value) {
  set_has_device_id();
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.VClock.device_id)
}
#endif
inline void VClock::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.VClock.device_id)
}
inline void VClock::set_device_id(const void* value, size_t size) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.VClock.device_id)
}
inline ::std::string* VClock::mutable_device_id() {
  set_has_device_id();
  // @@protoc_insertion_point(field_mutable:zina.VClock.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VClock::release_device_id() {
  // @@protoc_insertion_point(field_release:zina.VClock.device_id)
  if (!has_device_id()) {
    return NULL;
  }
  clear_has_device_id();
  return device_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VClock::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    set_has_device_id();
  } else {
    clear_has_device_id();
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:zina.VClock.device_id)
}

// optional int64 value = 2;
inline bool VClock::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VClock::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VClock::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VClock::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 VClock::value() const {
  // @@protoc_insertion_point(field_get:zina.VClock.value)
  return value_;
}
inline void VClock::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:zina.VClock.value)
}

// -------------------------------------------------------------------

// LocalVClock

// repeated .zina.VClock vclock = 1;
inline int LocalVClock::vclock_size() const {
  return vclock_.size();
}
inline void LocalVClock::clear_vclock() {
  vclock_.Clear();
}
inline ::zina::VClock* LocalVClock::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.LocalVClock.vclock)
  return vclock_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
LocalVClock::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.LocalVClock.vclock)
  return &vclock_;
}
inline const ::zina::VClock& LocalVClock::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.LocalVClock.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* LocalVClock::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.LocalVClock.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
LocalVClock::vclock() const {
  // @@protoc_insertion_point(field_list:zina.LocalVClock.vclock)
  return vclock_;
}

// optional bytes update_id = 2;
inline bool LocalVClock::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalVClock::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalVClock::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalVClock::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& LocalVClock::update_id() const {
  // @@protoc_insertion_point(field_get:zina.LocalVClock.update_id)
  return update_id_.GetNoArena();
}
inline void LocalVClock::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.LocalVClock.update_id)
}
#if LANG_CXX11
inline void LocalVClock::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.LocalVClock.update_id)
}
#endif
inline void LocalVClock::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.LocalVClock.update_id)
}
inline void LocalVClock::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.LocalVClock.update_id)
}
inline ::std::string* LocalVClock::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.LocalVClock.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LocalVClock::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.LocalVClock.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LocalVClock::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.LocalVClock.update_id)
}

// -------------------------------------------------------------------

// Member

// optional string user_id = 1;
inline bool Member::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& Member::user_id() const {
  // @@protoc_insertion_point(field_get:zina.Member.user_id)
  return user_id_.GetNoArena();
}
inline void Member::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.Member.user_id)
}
#if LANG_CXX11
inline void Member::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.Member.user_id)
}
#endif
inline void Member::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.Member.user_id)
}
inline void Member::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.Member.user_id)
}
inline ::std::string* Member::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:zina.Member.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Member::release_user_id() {
  // @@protoc_insertion_point(field_release:zina.Member.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Member::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:zina.Member.user_id)
}

// -------------------------------------------------------------------

// GroupUpdateSetName

// optional bytes update_id = 1;
inline bool GroupUpdateSetName::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateSetName::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateSetName::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateSetName::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateSetName::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.update_id)
  return update_id_.GetNoArena();
}
inline void GroupUpdateSetName::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetName.update_id)
}
#if LANG_CXX11
inline void GroupUpdateSetName::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetName.update_id)
}
#endif
inline void GroupUpdateSetName::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetName.update_id)
}
inline void GroupUpdateSetName::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetName.update_id)
}
inline ::std::string* GroupUpdateSetName::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetName::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetName.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetName::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetName.update_id)
}

// repeated .zina.VClock vclock = 2;
inline int GroupUpdateSetName::vclock_size() const {
  return vclock_.size();
}
inline void GroupUpdateSetName::clear_vclock() {
  vclock_.Clear();
}
inline ::zina::VClock* GroupUpdateSetName::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.vclock)
  return vclock_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
GroupUpdateSetName::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateSetName.vclock)
  return &vclock_;
}
inline const ::zina::VClock& GroupUpdateSetName::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* GroupUpdateSetName::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateSetName.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
GroupUpdateSetName::vclock() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateSetName.vclock)
  return vclock_;
}

// optional string name = 3;
inline bool GroupUpdateSetName::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateSetName::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateSetName::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateSetName::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GroupUpdateSetName::name() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.name)
  return name_.GetNoArena();
}
inline void GroupUpdateSetName::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetName.name)
}
#if LANG_CXX11
inline void GroupUpdateSetName::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetName.name)
}
#endif
inline void GroupUpdateSetName::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetName.name)
}
inline void GroupUpdateSetName::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetName.name)
}
inline ::std::string* GroupUpdateSetName::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetName::release_name() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetName.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetName::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetName.name)
}

// optional string user_id = 4;
inline bool GroupUpdateSetName::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateSetName::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateSetName::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateSetName::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& GroupUpdateSetName::user_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetName.user_id)
  return user_id_.GetNoArena();
}
inline void GroupUpdateSetName::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetName.user_id)
}
#if LANG_CXX11
inline void GroupUpdateSetName::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetName.user_id)
}
#endif
inline void GroupUpdateSetName::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetName.user_id)
}
inline void GroupUpdateSetName::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetName.user_id)
}
inline ::std::string* GroupUpdateSetName::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetName.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetName::release_user_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetName.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetName::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetName.user_id)
}

// -------------------------------------------------------------------

// GroupUpdateSetAvatar

// optional bytes update_id = 1;
inline bool GroupUpdateSetAvatar::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateSetAvatar::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateSetAvatar::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateSetAvatar::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateSetAvatar::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.update_id)
  return update_id_.GetNoArena();
}
inline void GroupUpdateSetAvatar::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetAvatar.update_id)
}
#if LANG_CXX11
inline void GroupUpdateSetAvatar::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetAvatar.update_id)
}
#endif
inline void GroupUpdateSetAvatar::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetAvatar.update_id)
}
inline void GroupUpdateSetAvatar::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetAvatar.update_id)
}
inline ::std::string* GroupUpdateSetAvatar::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetAvatar::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetAvatar.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetAvatar::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetAvatar.update_id)
}

// repeated .zina.VClock vclock = 2;
inline int GroupUpdateSetAvatar::vclock_size() const {
  return vclock_.size();
}
inline void GroupUpdateSetAvatar::clear_vclock() {
  vclock_.Clear();
}
inline ::zina::VClock* GroupUpdateSetAvatar::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.vclock)
  return vclock_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
GroupUpdateSetAvatar::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateSetAvatar.vclock)
  return &vclock_;
}
inline const ::zina::VClock& GroupUpdateSetAvatar::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* GroupUpdateSetAvatar::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateSetAvatar.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
GroupUpdateSetAvatar::vclock() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateSetAvatar.vclock)
  return vclock_;
}

// optional string avatar = 3;
inline bool GroupUpdateSetAvatar::has_avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateSetAvatar::set_has_avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateSetAvatar::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateSetAvatar::clear_avatar() {
  avatar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_avatar();
}
inline const ::std::string& GroupUpdateSetAvatar::avatar() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.avatar)
  return avatar_.GetNoArena();
}
inline void GroupUpdateSetAvatar::set_avatar(const ::std::string& value) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetAvatar.avatar)
}
#if LANG_CXX11
inline void GroupUpdateSetAvatar::set_avatar(::std::string&& value) {
  set_has_avatar();
  avatar_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetAvatar.avatar)
}
#endif
inline void GroupUpdateSetAvatar::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetAvatar.avatar)
}
inline void GroupUpdateSetAvatar::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetAvatar.avatar)
}
inline ::std::string* GroupUpdateSetAvatar::mutable_avatar() {
  set_has_avatar();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.avatar)
  return avatar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetAvatar::release_avatar() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetAvatar.avatar)
  if (!has_avatar()) {
    return NULL;
  }
  clear_has_avatar();
  return avatar_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetAvatar::set_allocated_avatar(::std::string* avatar) {
  if (avatar != NULL) {
    set_has_avatar();
  } else {
    clear_has_avatar();
  }
  avatar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetAvatar.avatar)
}

// optional string user_id = 4;
inline bool GroupUpdateSetAvatar::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateSetAvatar::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateSetAvatar::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateSetAvatar::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& GroupUpdateSetAvatar::user_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetAvatar.user_id)
  return user_id_.GetNoArena();
}
inline void GroupUpdateSetAvatar::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetAvatar.user_id)
}
#if LANG_CXX11
inline void GroupUpdateSetAvatar::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetAvatar.user_id)
}
#endif
inline void GroupUpdateSetAvatar::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetAvatar.user_id)
}
inline void GroupUpdateSetAvatar::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetAvatar.user_id)
}
inline ::std::string* GroupUpdateSetAvatar::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetAvatar.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetAvatar::release_user_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetAvatar.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetAvatar::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetAvatar.user_id)
}

// -------------------------------------------------------------------

// GroupUpdateSetBurn

// optional bytes update_id = 1;
inline bool GroupUpdateSetBurn::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateSetBurn::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateSetBurn::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateSetBurn::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateSetBurn::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.update_id)
  return update_id_.GetNoArena();
}
inline void GroupUpdateSetBurn::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.update_id)
}
#if LANG_CXX11
inline void GroupUpdateSetBurn::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetBurn.update_id)
}
#endif
inline void GroupUpdateSetBurn::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetBurn.update_id)
}
inline void GroupUpdateSetBurn::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetBurn.update_id)
}
inline ::std::string* GroupUpdateSetBurn::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetBurn.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetBurn::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetBurn.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetBurn::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetBurn.update_id)
}

// repeated .zina.VClock vclock = 2;
inline int GroupUpdateSetBurn::vclock_size() const {
  return vclock_.size();
}
inline void GroupUpdateSetBurn::clear_vclock() {
  vclock_.Clear();
}
inline ::zina::VClock* GroupUpdateSetBurn::mutable_vclock(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetBurn.vclock)
  return vclock_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::VClock >*
GroupUpdateSetBurn::mutable_vclock() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateSetBurn.vclock)
  return &vclock_;
}
inline const ::zina::VClock& GroupUpdateSetBurn::vclock(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.vclock)
  return vclock_.Get(index);
}
inline ::zina::VClock* GroupUpdateSetBurn::add_vclock() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateSetBurn.vclock)
  return vclock_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::VClock >&
GroupUpdateSetBurn::vclock() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateSetBurn.vclock)
  return vclock_;
}

// optional .zina.GroupUpdateSetBurn.BurnMode burn_mode = 3;
inline bool GroupUpdateSetBurn::has_burn_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupUpdateSetBurn::set_has_burn_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupUpdateSetBurn::clear_has_burn_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupUpdateSetBurn::clear_burn_mode() {
  burn_mode_ = 0;
  clear_has_burn_mode();
}
inline ::zina::GroupUpdateSetBurn_BurnMode GroupUpdateSetBurn::burn_mode() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.burn_mode)
  return static_cast< ::zina::GroupUpdateSetBurn_BurnMode >(burn_mode_);
}
inline void GroupUpdateSetBurn::set_burn_mode(::zina::GroupUpdateSetBurn_BurnMode value) {
  assert(::zina::GroupUpdateSetBurn_BurnMode_IsValid(value));
  set_has_burn_mode();
  burn_mode_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.burn_mode)
}

// optional uint64 burn_ttl_sec = 4;
inline bool GroupUpdateSetBurn::has_burn_ttl_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateSetBurn::set_has_burn_ttl_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateSetBurn::clear_has_burn_ttl_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateSetBurn::clear_burn_ttl_sec() {
  burn_ttl_sec_ = GOOGLE_ULONGLONG(0);
  clear_has_burn_ttl_sec();
}
inline ::google::protobuf::uint64 GroupUpdateSetBurn::burn_ttl_sec() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.burn_ttl_sec)
  return burn_ttl_sec_;
}
inline void GroupUpdateSetBurn::set_burn_ttl_sec(::google::protobuf::uint64 value) {
  set_has_burn_ttl_sec();
  burn_ttl_sec_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.burn_ttl_sec)
}

// optional string user_id = 5;
inline bool GroupUpdateSetBurn::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateSetBurn::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateSetBurn::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateSetBurn::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& GroupUpdateSetBurn::user_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateSetBurn.user_id)
  return user_id_.GetNoArena();
}
inline void GroupUpdateSetBurn::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateSetBurn.user_id)
}
#if LANG_CXX11
inline void GroupUpdateSetBurn::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateSetBurn.user_id)
}
#endif
inline void GroupUpdateSetBurn::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateSetBurn.user_id)
}
inline void GroupUpdateSetBurn::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateSetBurn.user_id)
}
inline ::std::string* GroupUpdateSetBurn::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateSetBurn.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateSetBurn::release_user_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateSetBurn.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateSetBurn::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateSetBurn.user_id)
}

// -------------------------------------------------------------------

// GroupUpdateAddMember

// optional bytes update_id = 1;
inline bool GroupUpdateAddMember::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateAddMember::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateAddMember::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateAddMember::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateAddMember::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAddMember.update_id)
  return update_id_.GetNoArena();
}
inline void GroupUpdateAddMember::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAddMember.update_id)
}
#if LANG_CXX11
inline void GroupUpdateAddMember::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateAddMember.update_id)
}
#endif
inline void GroupUpdateAddMember::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateAddMember.update_id)
}
inline void GroupUpdateAddMember::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateAddMember.update_id)
}
inline ::std::string* GroupUpdateAddMember::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAddMember.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateAddMember::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateAddMember.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateAddMember::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateAddMember.update_id)
}

// repeated .zina.Member addMember = 2;
inline int GroupUpdateAddMember::addmember_size() const {
  return addmember_.size();
}
inline void GroupUpdateAddMember::clear_addmember() {
  addmember_.Clear();
}
inline ::zina::Member* GroupUpdateAddMember::mutable_addmember(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAddMember.addMember)
  return addmember_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::Member >*
GroupUpdateAddMember::mutable_addmember() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateAddMember.addMember)
  return &addmember_;
}
inline const ::zina::Member& GroupUpdateAddMember::addmember(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAddMember.addMember)
  return addmember_.Get(index);
}
inline ::zina::Member* GroupUpdateAddMember::add_addmember() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateAddMember.addMember)
  return addmember_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
GroupUpdateAddMember::addmember() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateAddMember.addMember)
  return addmember_;
}

// optional string user_id = 3;
inline bool GroupUpdateAddMember::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateAddMember::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateAddMember::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateAddMember::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& GroupUpdateAddMember::user_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAddMember.user_id)
  return user_id_.GetNoArena();
}
inline void GroupUpdateAddMember::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAddMember.user_id)
}
#if LANG_CXX11
inline void GroupUpdateAddMember::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateAddMember.user_id)
}
#endif
inline void GroupUpdateAddMember::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateAddMember.user_id)
}
inline void GroupUpdateAddMember::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateAddMember.user_id)
}
inline ::std::string* GroupUpdateAddMember::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAddMember.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateAddMember::release_user_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateAddMember.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateAddMember::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateAddMember.user_id)
}

// -------------------------------------------------------------------

// GroupUpdateRmMember

// optional bytes update_id = 1;
inline bool GroupUpdateRmMember::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateRmMember::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateRmMember::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateRmMember::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateRmMember::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateRmMember.update_id)
  return update_id_.GetNoArena();
}
inline void GroupUpdateRmMember::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateRmMember.update_id)
}
#if LANG_CXX11
inline void GroupUpdateRmMember::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateRmMember.update_id)
}
#endif
inline void GroupUpdateRmMember::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateRmMember.update_id)
}
inline void GroupUpdateRmMember::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateRmMember.update_id)
}
inline ::std::string* GroupUpdateRmMember::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateRmMember.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateRmMember::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateRmMember.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateRmMember::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateRmMember.update_id)
}

// repeated .zina.Member rmMember = 2;
inline int GroupUpdateRmMember::rmmember_size() const {
  return rmmember_.size();
}
inline void GroupUpdateRmMember::clear_rmmember() {
  rmmember_.Clear();
}
inline ::zina::Member* GroupUpdateRmMember::mutable_rmmember(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateRmMember.rmMember)
  return rmmember_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::Member >*
GroupUpdateRmMember::mutable_rmmember() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupUpdateRmMember.rmMember)
  return &rmmember_;
}
inline const ::zina::Member& GroupUpdateRmMember::rmmember(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateRmMember.rmMember)
  return rmmember_.Get(index);
}
inline ::zina::Member* GroupUpdateRmMember::add_rmmember() {
  // @@protoc_insertion_point(field_add:zina.GroupUpdateRmMember.rmMember)
  return rmmember_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::Member >&
GroupUpdateRmMember::rmmember() const {
  // @@protoc_insertion_point(field_list:zina.GroupUpdateRmMember.rmMember)
  return rmmember_;
}

// optional string user_id = 3;
inline bool GroupUpdateRmMember::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateRmMember::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateRmMember::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateRmMember::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& GroupUpdateRmMember::user_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateRmMember.user_id)
  return user_id_.GetNoArena();
}
inline void GroupUpdateRmMember::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateRmMember.user_id)
}
#if LANG_CXX11
inline void GroupUpdateRmMember::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateRmMember.user_id)
}
#endif
inline void GroupUpdateRmMember::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateRmMember.user_id)
}
inline void GroupUpdateRmMember::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateRmMember.user_id)
}
inline ::std::string* GroupUpdateRmMember::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateRmMember.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateRmMember::release_user_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateRmMember.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateRmMember::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateRmMember.user_id)
}

// -------------------------------------------------------------------

// GroupBurnMessage

// optional bytes update_id = 1;
inline bool GroupBurnMessage::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupBurnMessage::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupBurnMessage::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupBurnMessage::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupBurnMessage::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupBurnMessage.update_id)
  return update_id_.GetNoArena();
}
inline void GroupBurnMessage::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupBurnMessage.update_id)
}
#if LANG_CXX11
inline void GroupBurnMessage::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupBurnMessage.update_id)
}
#endif
inline void GroupBurnMessage::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupBurnMessage.update_id)
}
inline void GroupBurnMessage::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupBurnMessage.update_id)
}
inline ::std::string* GroupBurnMessage::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupBurnMessage.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupBurnMessage::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupBurnMessage.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupBurnMessage::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupBurnMessage.update_id)
}

// repeated string msgId = 2;
inline int GroupBurnMessage::msgid_size() const {
  return msgid_.size();
}
inline void GroupBurnMessage::clear_msgid() {
  msgid_.Clear();
}
inline const ::std::string& GroupBurnMessage::msgid(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupBurnMessage.msgId)
  return msgid_.Get(index);
}
inline ::std::string* GroupBurnMessage::mutable_msgid(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupBurnMessage.msgId)
  return msgid_.Mutable(index);
}
inline void GroupBurnMessage::set_msgid(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zina.GroupBurnMessage.msgId)
  msgid_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GroupBurnMessage::set_msgid(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zina.GroupBurnMessage.msgId)
  msgid_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GroupBurnMessage::set_msgid(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  msgid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zina.GroupBurnMessage.msgId)
}
inline void GroupBurnMessage::set_msgid(int index, const char* value, size_t size) {
  msgid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zina.GroupBurnMessage.msgId)
}
inline ::std::string* GroupBurnMessage::add_msgid() {
  // @@protoc_insertion_point(field_add_mutable:zina.GroupBurnMessage.msgId)
  return msgid_.Add();
}
inline void GroupBurnMessage::add_msgid(const ::std::string& value) {
  msgid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zina.GroupBurnMessage.msgId)
}
#if LANG_CXX11
inline void GroupBurnMessage::add_msgid(::std::string&& value) {
  msgid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zina.GroupBurnMessage.msgId)
}
#endif
inline void GroupBurnMessage::add_msgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  msgid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zina.GroupBurnMessage.msgId)
}
inline void GroupBurnMessage::add_msgid(const char* value, size_t size) {
  msgid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zina.GroupBurnMessage.msgId)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupBurnMessage::msgid() const {
  // @@protoc_insertion_point(field_list:zina.GroupBurnMessage.msgId)
  return msgid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupBurnMessage::mutable_msgid() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupBurnMessage.msgId)
  return &msgid_;
}

// optional .zina.Member member = 3;
inline bool GroupBurnMessage::has_member() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupBurnMessage::set_has_member() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupBurnMessage::clear_has_member() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupBurnMessage::clear_member() {
  if (member_ != NULL) member_->Clear();
  clear_has_member();
}
inline const ::zina::Member& GroupBurnMessage::_internal_member() const {
  return *member_;
}
inline const ::zina::Member& GroupBurnMessage::member() const {
  const ::zina::Member* p = member_;
  // @@protoc_insertion_point(field_get:zina.GroupBurnMessage.member)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::Member*>(
      &::zina::_Member_default_instance_);
}
inline ::zina::Member* GroupBurnMessage::release_member() {
  // @@protoc_insertion_point(field_release:zina.GroupBurnMessage.member)
  clear_has_member();
  ::zina::Member* temp = member_;
  member_ = NULL;
  return temp;
}
inline ::zina::Member* GroupBurnMessage::mutable_member() {
  set_has_member();
  if (member_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::Member>(GetArenaNoVirtual());
    member_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupBurnMessage.member)
  return member_;
}
inline void GroupBurnMessage::set_allocated_member(::zina::Member* member) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete member_;
  }
  if (member) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      member = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, member, submessage_arena);
    }
    set_has_member();
  } else {
    clear_has_member();
  }
  member_ = member;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupBurnMessage.member)
}

// -------------------------------------------------------------------

// GroupUpdateAck

// optional .zina.GroupUpdateType type = 1;
inline bool GroupUpdateAck::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupUpdateAck::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupUpdateAck::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupUpdateAck::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zina::GroupUpdateType GroupUpdateAck::type() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAck.type)
  return static_cast< ::zina::GroupUpdateType >(type_);
}
inline void GroupUpdateAck::set_type(::zina::GroupUpdateType value) {
  assert(::zina::GroupUpdateType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAck.type)
}

// optional bytes update_id = 2;
inline bool GroupUpdateAck::has_update_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupUpdateAck::set_has_update_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupUpdateAck::clear_has_update_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupUpdateAck::clear_update_id() {
  update_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_update_id();
}
inline const ::std::string& GroupUpdateAck::update_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAck.update_id)
  return update_id_.GetNoArena();
}
inline void GroupUpdateAck::set_update_id(const ::std::string& value) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAck.update_id)
}
#if LANG_CXX11
inline void GroupUpdateAck::set_update_id(::std::string&& value) {
  set_has_update_id();
  update_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupUpdateAck.update_id)
}
#endif
inline void GroupUpdateAck::set_update_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupUpdateAck.update_id)
}
inline void GroupUpdateAck::set_update_id(const void* value, size_t size) {
  set_has_update_id();
  update_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupUpdateAck.update_id)
}
inline ::std::string* GroupUpdateAck::mutable_update_id() {
  set_has_update_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupUpdateAck.update_id)
  return update_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupUpdateAck::release_update_id() {
  // @@protoc_insertion_point(field_release:zina.GroupUpdateAck.update_id)
  if (!has_update_id()) {
    return NULL;
  }
  clear_has_update_id();
  return update_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupUpdateAck::set_allocated_update_id(::std::string* update_id) {
  if (update_id != NULL) {
    set_has_update_id();
  } else {
    clear_has_update_id();
  }
  update_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupUpdateAck.update_id)
}

// optional .zina.GroupUpdateResult result = 3;
inline bool GroupUpdateAck::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupUpdateAck::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupUpdateAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupUpdateAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::zina::GroupUpdateResult GroupUpdateAck::result() const {
  // @@protoc_insertion_point(field_get:zina.GroupUpdateAck.result)
  return static_cast< ::zina::GroupUpdateResult >(result_);
}
inline void GroupUpdateAck::set_result(::zina::GroupUpdateResult value) {
  assert(::zina::GroupUpdateResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:zina.GroupUpdateAck.result)
}

// -------------------------------------------------------------------

// GroupChangeSet

// optional bytes group_id = 1;
inline bool GroupChangeSet::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChangeSet::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChangeSet::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChangeSet::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group_id();
}
inline const ::std::string& GroupChangeSet::group_id() const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.group_id)
  return group_id_.GetNoArena();
}
inline void GroupChangeSet::set_group_id(const ::std::string& value) {
  set_has_group_id();
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zina.GroupChangeSet.group_id)
}
#if LANG_CXX11
inline void GroupChangeSet::set_group_id(::std::string&& value) {
  set_has_group_id();
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zina.GroupChangeSet.group_id)
}
#endif
inline void GroupChangeSet::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_group_id();
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zina.GroupChangeSet.group_id)
}
inline void GroupChangeSet::set_group_id(const void* value, size_t size) {
  set_has_group_id();
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zina.GroupChangeSet.group_id)
}
inline ::std::string* GroupChangeSet::mutable_group_id() {
  set_has_group_id();
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupChangeSet::release_group_id() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.group_id)
  if (!has_group_id()) {
    return NULL;
  }
  clear_has_group_id();
  return group_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupChangeSet::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    set_has_group_id();
  } else {
    clear_has_group_id();
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.group_id)
}

// optional .zina.GroupUpdateSetName updateName = 2;
inline bool GroupChangeSet::has_updatename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChangeSet::set_has_updatename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChangeSet::clear_has_updatename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChangeSet::clear_updatename() {
  if (updatename_ != NULL) updatename_->Clear();
  clear_has_updatename();
}
inline const ::zina::GroupUpdateSetName& GroupChangeSet::_internal_updatename() const {
  return *updatename_;
}
inline const ::zina::GroupUpdateSetName& GroupChangeSet::updatename() const {
  const ::zina::GroupUpdateSetName* p = updatename_;
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateName)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::GroupUpdateSetName*>(
      &::zina::_GroupUpdateSetName_default_instance_);
}
inline ::zina::GroupUpdateSetName* GroupChangeSet::release_updatename() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.updateName)
  clear_has_updatename();
  ::zina::GroupUpdateSetName* temp = updatename_;
  updatename_ = NULL;
  return temp;
}
inline ::zina::GroupUpdateSetName* GroupChangeSet::mutable_updatename() {
  set_has_updatename();
  if (updatename_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::GroupUpdateSetName>(GetArenaNoVirtual());
    updatename_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateName)
  return updatename_;
}
inline void GroupChangeSet::set_allocated_updatename(::zina::GroupUpdateSetName* updatename) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updatename_;
  }
  if (updatename) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updatename = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updatename, submessage_arena);
    }
    set_has_updatename();
  } else {
    clear_has_updatename();
  }
  updatename_ = updatename;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateName)
}

// optional .zina.GroupUpdateSetAvatar updateAvatar = 3;
inline bool GroupChangeSet::has_updateavatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupChangeSet::set_has_updateavatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupChangeSet::clear_has_updateavatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupChangeSet::clear_updateavatar() {
  if (updateavatar_ != NULL) updateavatar_->Clear();
  clear_has_updateavatar();
}
inline const ::zina::GroupUpdateSetAvatar& GroupChangeSet::_internal_updateavatar() const {
  return *updateavatar_;
}
inline const ::zina::GroupUpdateSetAvatar& GroupChangeSet::updateavatar() const {
  const ::zina::GroupUpdateSetAvatar* p = updateavatar_;
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateAvatar)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::GroupUpdateSetAvatar*>(
      &::zina::_GroupUpdateSetAvatar_default_instance_);
}
inline ::zina::GroupUpdateSetAvatar* GroupChangeSet::release_updateavatar() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.updateAvatar)
  clear_has_updateavatar();
  ::zina::GroupUpdateSetAvatar* temp = updateavatar_;
  updateavatar_ = NULL;
  return temp;
}
inline ::zina::GroupUpdateSetAvatar* GroupChangeSet::mutable_updateavatar() {
  set_has_updateavatar();
  if (updateavatar_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::GroupUpdateSetAvatar>(GetArenaNoVirtual());
    updateavatar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateAvatar)
  return updateavatar_;
}
inline void GroupChangeSet::set_allocated_updateavatar(::zina::GroupUpdateSetAvatar* updateavatar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updateavatar_;
  }
  if (updateavatar) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updateavatar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updateavatar, submessage_arena);
    }
    set_has_updateavatar();
  } else {
    clear_has_updateavatar();
  }
  updateavatar_ = updateavatar;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateAvatar)
}

// optional .zina.GroupUpdateSetBurn updateBurn = 4;
inline bool GroupChangeSet::has_updateburn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupChangeSet::set_has_updateburn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupChangeSet::clear_has_updateburn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupChangeSet::clear_updateburn() {
  if (updateburn_ != NULL) updateburn_->Clear();
  clear_has_updateburn();
}
inline const ::zina::GroupUpdateSetBurn& GroupChangeSet::_internal_updateburn() const {
  return *updateburn_;
}
inline const ::zina::GroupUpdateSetBurn& GroupChangeSet::updateburn() const {
  const ::zina::GroupUpdateSetBurn* p = updateburn_;
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateBurn)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::GroupUpdateSetBurn*>(
      &::zina::_GroupUpdateSetBurn_default_instance_);
}
inline ::zina::GroupUpdateSetBurn* GroupChangeSet::release_updateburn() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.updateBurn)
  clear_has_updateburn();
  ::zina::GroupUpdateSetBurn* temp = updateburn_;
  updateburn_ = NULL;
  return temp;
}
inline ::zina::GroupUpdateSetBurn* GroupChangeSet::mutable_updateburn() {
  set_has_updateburn();
  if (updateburn_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::GroupUpdateSetBurn>(GetArenaNoVirtual());
    updateburn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateBurn)
  return updateburn_;
}
inline void GroupChangeSet::set_allocated_updateburn(::zina::GroupUpdateSetBurn* updateburn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updateburn_;
  }
  if (updateburn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updateburn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updateburn, submessage_arena);
    }
    set_has_updateburn();
  } else {
    clear_has_updateburn();
  }
  updateburn_ = updateburn;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateBurn)
}

// optional .zina.GroupUpdateAddMember updateAddMember = 5;
inline bool GroupChangeSet::has_updateaddmember() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupChangeSet::set_has_updateaddmember() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupChangeSet::clear_has_updateaddmember() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupChangeSet::clear_updateaddmember() {
  if (updateaddmember_ != NULL) updateaddmember_->Clear();
  clear_has_updateaddmember();
}
inline const ::zina::GroupUpdateAddMember& GroupChangeSet::_internal_updateaddmember() const {
  return *updateaddmember_;
}
inline const ::zina::GroupUpdateAddMember& GroupChangeSet::updateaddmember() const {
  const ::zina::GroupUpdateAddMember* p = updateaddmember_;
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateAddMember)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::GroupUpdateAddMember*>(
      &::zina::_GroupUpdateAddMember_default_instance_);
}
inline ::zina::GroupUpdateAddMember* GroupChangeSet::release_updateaddmember() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.updateAddMember)
  clear_has_updateaddmember();
  ::zina::GroupUpdateAddMember* temp = updateaddmember_;
  updateaddmember_ = NULL;
  return temp;
}
inline ::zina::GroupUpdateAddMember* GroupChangeSet::mutable_updateaddmember() {
  set_has_updateaddmember();
  if (updateaddmember_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::GroupUpdateAddMember>(GetArenaNoVirtual());
    updateaddmember_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateAddMember)
  return updateaddmember_;
}
inline void GroupChangeSet::set_allocated_updateaddmember(::zina::GroupUpdateAddMember* updateaddmember) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updateaddmember_;
  }
  if (updateaddmember) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updateaddmember = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updateaddmember, submessage_arena);
    }
    set_has_updateaddmember();
  } else {
    clear_has_updateaddmember();
  }
  updateaddmember_ = updateaddmember;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateAddMember)
}

// optional .zina.GroupUpdateRmMember updateRmMember = 6;
inline bool GroupChangeSet::has_updatermmember() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupChangeSet::set_has_updatermmember() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupChangeSet::clear_has_updatermmember() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupChangeSet::clear_updatermmember() {
  if (updatermmember_ != NULL) updatermmember_->Clear();
  clear_has_updatermmember();
}
inline const ::zina::GroupUpdateRmMember& GroupChangeSet::_internal_updatermmember() const {
  return *updatermmember_;
}
inline const ::zina::GroupUpdateRmMember& GroupChangeSet::updatermmember() const {
  const ::zina::GroupUpdateRmMember* p = updatermmember_;
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.updateRmMember)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::GroupUpdateRmMember*>(
      &::zina::_GroupUpdateRmMember_default_instance_);
}
inline ::zina::GroupUpdateRmMember* GroupChangeSet::release_updatermmember() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.updateRmMember)
  clear_has_updatermmember();
  ::zina::GroupUpdateRmMember* temp = updatermmember_;
  updatermmember_ = NULL;
  return temp;
}
inline ::zina::GroupUpdateRmMember* GroupChangeSet::mutable_updatermmember() {
  set_has_updatermmember();
  if (updatermmember_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::GroupUpdateRmMember>(GetArenaNoVirtual());
    updatermmember_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.updateRmMember)
  return updatermmember_;
}
inline void GroupChangeSet::set_allocated_updatermmember(::zina::GroupUpdateRmMember* updatermmember) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete updatermmember_;
  }
  if (updatermmember) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      updatermmember = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, updatermmember, submessage_arena);
    }
    set_has_updatermmember();
  } else {
    clear_has_updatermmember();
  }
  updatermmember_ = updatermmember;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.updateRmMember)
}

// optional .zina.GroupBurnMessage burnMessage = 8;
inline bool GroupChangeSet::has_burnmessage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupChangeSet::set_has_burnmessage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupChangeSet::clear_has_burnmessage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupChangeSet::clear_burnmessage() {
  if (burnmessage_ != NULL) burnmessage_->Clear();
  clear_has_burnmessage();
}
inline const ::zina::GroupBurnMessage& GroupChangeSet::_internal_burnmessage() const {
  return *burnmessage_;
}
inline const ::zina::GroupBurnMessage& GroupChangeSet::burnmessage() const {
  const ::zina::GroupBurnMessage* p = burnmessage_;
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.burnMessage)
  return p != NULL ? *p : *reinterpret_cast<const ::zina::GroupBurnMessage*>(
      &::zina::_GroupBurnMessage_default_instance_);
}
inline ::zina::GroupBurnMessage* GroupChangeSet::release_burnmessage() {
  // @@protoc_insertion_point(field_release:zina.GroupChangeSet.burnMessage)
  clear_has_burnmessage();
  ::zina::GroupBurnMessage* temp = burnmessage_;
  burnmessage_ = NULL;
  return temp;
}
inline ::zina::GroupBurnMessage* GroupChangeSet::mutable_burnmessage() {
  set_has_burnmessage();
  if (burnmessage_ == NULL) {
    auto* p = CreateMaybeMessage<::zina::GroupBurnMessage>(GetArenaNoVirtual());
    burnmessage_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.burnMessage)
  return burnmessage_;
}
inline void GroupChangeSet::set_allocated_burnmessage(::zina::GroupBurnMessage* burnmessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete burnmessage_;
  }
  if (burnmessage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      burnmessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, burnmessage, submessage_arena);
    }
    set_has_burnmessage();
  } else {
    clear_has_burnmessage();
  }
  burnmessage_ = burnmessage;
  // @@protoc_insertion_point(field_set_allocated:zina.GroupChangeSet.burnMessage)
}

// repeated .zina.GroupUpdateAck acks = 7;
inline int GroupChangeSet::acks_size() const {
  return acks_.size();
}
inline void GroupChangeSet::clear_acks() {
  acks_.Clear();
}
inline ::zina::GroupUpdateAck* GroupChangeSet::mutable_acks(int index) {
  // @@protoc_insertion_point(field_mutable:zina.GroupChangeSet.acks)
  return acks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >*
GroupChangeSet::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:zina.GroupChangeSet.acks)
  return &acks_;
}
inline const ::zina::GroupUpdateAck& GroupChangeSet::acks(int index) const {
  // @@protoc_insertion_point(field_get:zina.GroupChangeSet.acks)
  return acks_.Get(index);
}
inline ::zina::GroupUpdateAck* GroupChangeSet::add_acks() {
  // @@protoc_insertion_point(field_add:zina.GroupChangeSet.acks)
  return acks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zina::GroupUpdateAck >&
GroupChangeSet::acks() const {
  // @@protoc_insertion_point(field_list:zina.GroupChangeSet.acks)
  return acks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zina

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zina::GroupUpdateSetBurn_BurnMode> : ::std::true_type {};
template <> struct is_proto_enum< ::zina::GroupUpdateType> : ::std::true_type {};
template <> struct is_proto_enum< ::zina::GroupUpdateResult> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_GroupProtocol_2eproto
